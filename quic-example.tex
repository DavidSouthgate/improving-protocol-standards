\documentclass[10pt,a4paper,landscape]{article}
\usepackage[margin=0.3in]{geometry}
\usepackage{adjustbox}
\usepackage{array}
\usepackage{color}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{longtable}

\title{Packet Header Description Example: QUIC}
\date{}

\newcommand{\todo}[1]{\textbf{\textcolor{red}{To do -- #1}}}

\makeatletter
\newcolumntype{V}[1]{>{\topsep=0pt\@minipagetrue}p{#1}<{\vspace{-\baselineskip}}}
\makeatother

\begin{document}
\maketitle
	\begin{longtable}{V{370pt}|V{200pt}|V{200pt}}
	\toprule
	Packet Header Description Language & Type Definitions & Parsing Code \\
	\hline
		\begin{verbatim}
			packet_type := bit[7];
			version := bit[32];
			cid_len := bit[4];
			full_packet_num := bit[62];
			frame_type := bit[8];
		\end{verbatim}
		& 
		\begin{verbatim}
			typedef bit[7] packet_type;
			typedef bit[32] version;
			typedef bit[4] cid_len;
			typedef bit[62] full_packet_num;
			typedef bit[8] frame_type;
		\end{verbatim}
		 &
		\begin{verbatim}
			todo
		\end{verbatim}
	\\ \hline
		\begin{verbatim}
			var_enc := {
			    bit[2]  length;
			    bit[]   value;
			} where {
			    value#width = (2^length#value * 8) - 2;
			}
		\end{verbatim}
		& 
		\begin{verbatim}
			struct var_enc {
			    bit    length[2];
			    bit    value[]
			};
		\end{verbatim}
		 &
		\begin{verbatim}
			todo
		\end{verbatim}
	\\ \hline
		\begin{verbatim}
			packet_num :=
			    '0'  followed by bit[7]  packet_number
			  | '00' followed by bit[14] packet_number
			  | '01' followed by bit[30] packet_number;
		\end{verbatim}
		& 
		\begin{verbatim}
			enum packet_num {bit[7],
			                 bit[14], 
			                 bit[30]};
		\end{verbatim}
		 &
		\begin{verbatim}
			todo
		\end{verbatim}
	\\ \hline
		\begin{verbatim}
			decrypt :: (cryptobits[] enc_payload, full_packet_num pn) -> FRAME[]
		\end{verbatim}
		& 
		\begin{verbatim}
			todo
		\end{verbatim}
		 &
		\begin{verbatim}
			todo
		\end{verbatim}
	\\ \hline
		\begin{verbatim}
			QUIC_PDU :=
			    LONG_HDR
			  | SHORT_HDR
			  | VERSION_NEGOTIATION;
		\end{verbatim}
		& 
		\begin{verbatim}
			enum quic_pdu {long_hdr,
			               short_hdr, 
			               version_negotiation};
		\end{verbatim}
		 &
		\begin{verbatim}
			todo
		\end{verbatim}
	\\ \hline
		\begin{verbatim}
			LONG_HDR := {
			    bit          header_type;
			    packet_type  type;
			    version      ver;
			    cid_len      dcid_len;
			    cid_len      scid_len;
			    bit[]        dcid;
			    bit[]        scid;
			    var_enc      payload_length;
			    packet_num   packet_number;
			    bit[]        payload;
			} where {
			    header_type#value = 1;
			    dcid#width = dcid_len#value == 0 ? 0 : (dcid_len#value+3) * 8;
			    scid#width = scid_len#value == 0 ? 0 : (scid_len#value+3) * 8;
			    payload#width = 2^payload_length#value;
			} onparse {
			    context.scid_len = scid_len;
			}
		\end{verbatim}
		& 
		\begin{verbatim}
			struct long_hdr {
			    bit         header_type;
			    packet_type type;
			    version     ver;
			    cid_len     dcid_len;
			    cid_len     scid_len;
			    bit         dcid[];
			    bit         scid[];
			    var_enc     payload_length;
			    packet_num  packet_number;
			    bit         payload[];
			};
		\end{verbatim}
		 &
		\begin{verbatim}
			todo
		\end{verbatim}
	\\ \hline
		\begin{verbatim}
			SHORT_HDR := {
			    bit         header_type;
			    bit         key_phase;
			    bit         third_bit;
			    bit         forth_bit;
			    bit         google_demux;
			    bit[3]      reserved;
			    bit[]       dcid;
			    packet_num  packet_number;
			    cryptobit[] protected_payload; -> frame[] payload;
			} where {
			    header_type#value = 0;
			    third_bit#value = 1;
			    forth_bit#value = 1;
			    google_demux#value = 0;
			    dcid#length = context.scid_len#value == 0 ? 0 : 
			                            (context.scid_len#value+3) * 8;
			    payload = decrypt(protected_payload, packet_number);
			}
		\end{verbatim}
		& 
		\begin{verbatim}
			struct short_hdr {
			    bit        header_type;
			    bit        key_phase;
			    bit        third_bit;
			    bit        forth_bit;
			    bit        google_demux;
			    bit        reserved[3];
			    bit        dcid[];
			    packet_num packet_number;
			    cryptobit  protected_payload[];
			};
		\end{verbatim}
		 &
		\begin{verbatim}
			todo
		\end{verbatim}
	\\ \hline
		\begin{verbatim}
			VERSION_NEGOTIATION := {
			    bit          header_type;
			    bit[7]       unused;
			    version      ver;
			    cid_len      dcid_len;
			    cid_len      scid_len;
			    bit[]        dcid;
			    bit[]        scid;
			    version[]    supported_versions;
			} where {
			    header_type#value = 1;
			    ver#value = 0;
			    dcid#width = dcid_len#value == 0 ? 0 : 
			                        (dcid_len#value+3) * 8;
			    scid#width = scid_len#value == 0 ? 0 : 
			                        (scid_len#value+3) * 8;
			}
		\end{verbatim}
		& 
		\begin{verbatim}
			struct version_negotiation {
			    bit      header_type;
			    bit      unused[7];
			    version  ver;
			    cid_len  dcid_len;
			    cid_len  scid_len;
			    bit      dcid[];
			    bit      scid[];
			    version  supported_versions[];
			};
		\end{verbatim}
		 &
		\begin{verbatim}
			todo
		\end{verbatim}
	\\ \hline
		\begin{verbatim}
			FRAME := {
			    PADDING_FRAME
			  | RST_STREAM_FRAME
			  | CONNECTION_CLOSE_FRAME
			  | ..};
		\end{verbatim}
		& 
		\begin{verbatim}
			enum frame {padding_frame, 
			            rst_stream_frame, 
			            connection_close_frame,
			            ..};
		\end{verbatim}
		 &
		\begin{verbatim}
			todo
		\end{verbatim}
	\\ \hline
		\begin{verbatim}
			PADDING_FRAME := {
			    frame_type type;
			} where {
			    type#value = 0;
			}
		\end{verbatim}
		& 
		\begin{verbatim}
			struct padding_frame {
			    frame_type type;
			};
		\end{verbatim}
		 &
		\begin{verbatim}
			todo
		\end{verbatim}
	\\
	\bottomrule
	\end{longtable}
\end{document}
