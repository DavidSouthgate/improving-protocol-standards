\documentclass[10pt,twocolumn,a4paper]{article}
\usepackage[l2tabu,orthodox]{nag}
\usepackage[utf8x]{inputenc}
\usepackage[british]{babel}
\usepackage[babel=true]{microtype}
\usepackage{amsmath}
\usepackage[all]{onlyamsmath}
\usepackage{newtxtext} 
\usepackage{newtxmath} 
\usepackage{upquote}
\usepackage{graphicx}
\usepackage{url}
\usepackage[caption=false]{subfig}
\usepackage{booktabs}
\usepackage{bytefield}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{color}
\usepackage{fullpage}
\usepackage{no-par-indent}
\usepackage{alltt}
\frenchspacing
\newcommand{\todo}[1]{\textit{\textcolor{red}{[To do: #1]}}}
\newcommand{\code}[1]{\texttt{#1}}
%==================================================================================================
\begin{document}
\title{The Glasgow Packet Language: Intermediate Representation and Execution Model}
\author{
  Stephen McQuistin\\University of Glasgow
\and 
  Colin Perkins\\University of Glasgow
}
\date{\today}
\maketitle
%==================================================================================================
\begin{abstract}

% Four sentences:
%  - State the problem
%  - Say why it's an interesting problem
%  - Say what your solution achieves
%  - Say what follows from your solution



\end{abstract}
%==================================================================================================
\section{Introduction}

% Paragraph 1: Motivation. At a high level, what is the problem area you
% are working in and why is it important? It is important to set the larger
% context here. Why is the problem of interest and importance to the larger
% community?



% Paragraph 2: What is the specific problem considered in this paper? This
% paragraph narrows down the topic area of the paper. In the first
% paragraph you have established general context and importance. Here you
% establish specific context and background.



% Paragraph 3: "In this paper, we show that...". This is the key paragraph
% in the introduction - you summarize, in one paragraph, what are the main
% contributions of your paper, given the context established in paragraphs 
% 1 and 2. What's the general approach taken? Why are the specific results
% significant? The story is not what you did, but rather:
%  - what you show, new ideas, new insights
%  - why interesting, important?
% State your contributions: these drive the entire paper.  Contributions
% should be refutable claims, not vague generic statements.



% Paragraph 4: What are the differences between your work, and what others
% have done? Keep this at a high level, as you can refer to future sections
% where specific details and differences will be given, but it is important
% for the reader to know what is new about this work compared to other work
% in the area.



% Paragraph 5: "We structure the remainder of this paper as follows." Give
% the reader a road-map for the rest of the paper. Try to avoid redundant
% phrasing, "In Section 2, In section 3, ..., In Section 4, ... ", etc.


%==================================================================================================
\section{Terminology}

The key words ``MUST'', ``MUST NOT'', ``REQUIRED'', ``SHALL'', ``SHALL
NOT'', ``SHOULD'', ``SHOULD NOT'', ``RECOMMENDED'', ``NOT RECOMMENDED'',
``MAY'', and ``OPTIONAL'' in this document are to be interpreted as
described in \cite{RFC2119,RFC8174} when, and only when, they appear
in all capitals, as shown here.



The intermediate representation is specified in terms of serialised JSON
\cite{RFC7159} objects that describe the packet formats to be specified.
An interpreter for the intermediate representation will read a sequence of
such objects and perform the operations described, in the order that they
objects are read.

%==================================================================================================
\section{Type System}

Types can be \emph{internal} or \emph{representable}. A representable type
describes something that can be parsed or serialised. An internal type is
an artefact of the runtime, and cannot be parsed or serialised.

Each type has \emph{name}. It implements one or more \emph{traits} that
define \emph{methods} that can operate on instances of that type. Some
types also have \emph{values} and \emph{attributes}.

%--------------------------------------------------------------------------------------------------
\subsection{Internal Types}



% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Primitive Types}
\label{sec:primitives}

The \code{Nothing} type is the empty type. It has no value and no attributes,
and implement no traits.

The \code{Boolean} type is a boolean value, either \code{true} or \code{false}.
It implements the traits \code{Value}, \code{Equality} (two \code{Boolean}s are equal if
they have the same value), and \code{BooleanOps}.

The \code{Size} type is a positive integral value, denoting the size of an
instance of a representable type. It implements the traits \code{Value},
\code{Equality}, \code{Ordinal}, and \code{ArithmeticOps}.

The \code{Integer} type is an integer value. It implements the traits \code{Value},
\code{Equality}, \code{Ordinal}, and \code{ArithmeticOps}.

The primitive types are built-in to the runtime, and are not explicitly
defined in the JSON form of the intermediate representation.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Traits}
\label{sec:traits}

Traits define the methods that can operate on instances of types that
implement the trait.

A trait definition includes the name of the trait, and the definitions
of the methods. It defines a new type that has the specified name.

The name of a trait is formed of upper and lower case ASCII letters,
digits, or dollar signs (\code{A-Za-z0-9\$}); it MUST begin with an
upper case letter (\code{A-Z}). Trait names are defined in the global type
namespace.  It is an error to define a trait that has the same name as an
existing type.

Each method definition include the method name, return type, parameters.
Methods take one or more parameters.
The first parameter of a method MUST have the name \code{self} and MUST
have an unspecified type.
Other parameters, if any, MUST have names that are unique within that
method definition, and can have specified or unspecified types.
The return type of a method can be specified or unspecified.  
It is an error to define two methods that have the same name.

Method names and parameter names are formed of upper and lower case ASCII
letters, digits, dollar signs, or underscores (\code{A-Za-z0-9\$\_});
they MUST begin with a lower case letter (\code{a-z}).

When a type implements a trait, any unspecified types are set to the
implementing type.

When a method is called on an instance of a type that implements a trait,
that instance will be passed as the first parameter of the method.

In the JSON form of the intermediate representation, a trait definition is
represented as in the following:
\footnotesize
\begin{alltt}
  {
    "construct"   : "Trait"
    "name"        : "\emph{name}",
    "methods"     : [
      \{
        "name"       : "\emph{method name}",
        "parameters" : [
          \{
            "name" : "\emph{parameter name}",
            "type" : "\emph{parameter type}"
          \},
          ...
        ],
        "return\_type" : "\emph{return type}"
      \},
      ...
    ]
  }
\end{alltt}
\normalsize
Unspecified types are indicated by \code{null} values in the JSON definition
(this is distinct from a return value of \code{Nothing} that needs to be
explicitly stated).

The runtime implements the \code{Value} trait. This defines methods
that can be used to get and set the value of an instance of a type. 
Its definition is equivalent to the following definition in the JSON
form of the intermediate representation:
\footnotesize
\begin{alltt}
  \{
    "construct" : "Trait"
    "name"      : "Value",
    "methods"   : [
      \{
        "name"        : "get",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\}
        ],
        "return\_type" : null
      \},
      \{
        "name"        : "set",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "value", "type"   : null\}
        ],
        "return\_type" : "Nothing"
      \}
    ]
  \}
\end{alltt}
\normalsize

The runtime implements the \code{IndexedCollection} trait. This defines methods that can
be used to get and set the values of elements of an array-like data structure, which has
multiple, numerically indexed elements. Its definition is equivalent to the following
definition in the JSON form of the intermediate representation:
\footnotesize
\begin{alltt}
  \{
    "construct" : "Trait"
    "name"      : "IndexedCollection",
    "methods"   : [
      \{
        "name"        : "get",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "index", "type"   : "Size"\}
        ],
        "return\_type" : null
      \},
      \{
        "name"        : "set",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "index", "type"   : "Size"\}
          \{"name" : "value", "type"   : null\}
        ],
        "return\_type" : "Nothing"
      \}
    ]
  \}
\end{alltt}
\normalsize

The runtime implements the \code{NamedCollection} trait. This defines methods that can
be used to get and set the values of elements of a map-like data structure, which has
multiple, named indexed elements. Its definition is equivalent to the following
definition in the JSON form of the intermediate representation:
\footnotesize
\begin{alltt}
  \{
    "construct" : "Trait"
    "name"      : "NamedCollection",
    "methods"   : [
      \{
        "name"        : "get",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "key", "type"   : "String"\}
        ],
        "return\_type" : null
      \},
      \{
        "name"        : "set",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "key", "type"   : "String"\}
          \{"name" : "value", "type"   : null\}
        ],
        "return\_type" : "Nothing"
      \}
    ]
  \}
\end{alltt}
\normalsize

The runtime implements the \code{Equality} trait. This defines methods that
can be used to compare to instances of a type for equality.
Its definition is equivalent to the following definition in the JSON
form of the intermediate representation:
\footnotesize
\begin{alltt}
  \{
    "construct" : "Trait"
    "name"      : "Equality",
    "methods"   : [
      \{
        "name"        : "eq",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : "Boolean"
      \},
      \{
        "name"        : "ne",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : "Boolean"
      \}
    ]
  \}
\end{alltt}
\normalsize

The runtime implements the \code{Ordinal} trait. This defines methods that
can be used to compare the values of instances of a type. 
Its definition is equivalent to the following definition in the JSON
form of the intermediate representation:
\footnotesize
\begin{alltt}
  \{
    "construct" : "Trait"
    "name"      : "Ordinal",
    "methods"   : [
      \{
        "name"        : "lt",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : "Boolean"
      \},
      \{
        "name"        : "le",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : "Boolean"
      \},
      \{
        "name"        : "gt",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : "Boolean"
      \},
      \{
        "name"        : "ge",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : "Boolean"
      \}
    ]
  \}
\end{alltt}
\normalsize

The runtime implements the \code{BooleanOps} trait. This defines methods
that can be used to perform boolean operations on, and between, instances
of a type.
Its definition is equivalent to the following definition in the JSON
form of the intermediate representation:
\footnotesize
\begin{alltt}
  \{
    "construct" : "Trait"
    "name"      : "BooleanOps",
    "methods"   : [
      \{
        "name"        : "and",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : "Boolean"
      \},
      \{
        "name"        : "or",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : "Boolean"
      \},
      \{
        "name"        : "not",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\}
        ],
        "return\_type" : "Boolean"
      \}
    ]
  \}
\end{alltt}
\normalsize

The runtime implements the \code{ArithmeticOps} trait. This defines methods
that can be used to perform arithmetic operations on instances of a type.
Its definition is equivalent to the following definition in the JSON
form of the intermediate representation:
\footnotesize
\begin{alltt}
  \{
    "construct" : "Trait"
    "name"      : "ArithmeticOps",
    "methods"   : [
      \{
        "name"        : "plus",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : null
      \},
      \{
        "name"        : "minus",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : null
      \},
      \{
        "name"        : "multiply",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : null
      \},
      \{
        "name"        : "divide",
        "parameters"  : [
          \{"name" : "self",  "type"   : null\},
          \{"name" : "other", "type"   : null\}
        ],
        "return\_type" : null
      \}
    ]
  \}
\end{alltt}
\normalsize

%--------------------------------------------------------------------------------------------------
\subsection{Representable Types}
\label{sec:representable}

The runtime does not define any representable types. Rather, it defines
a number of \emph{type constructors} that allow appropriate types to be
created as needed to represent a protocol.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Bit String Types}
\label{sec:bit-string}

The bit string type constructor allows construction of types representing
multi-bit values that can be parsed or serialised. The type constructor
has a single attribute, \code{width}, of type \code{Size}, that indicates
the number of bits in the resulting type. The width MAY be unspecified.

Instances of bit string types implement the \code{Value} and
\code{Equality} traits. The former allows the value of the \code{BitString}
instantiation to be retrieved and set. The latter allows two instantiations
of \code{BitString} to be compared for equality; they are equal if they
have the same name, value, and \code{width}.

In the JSON form of the intermediate representation, an invocation of the
bit string type constructor is represented as in the following:
\footnotesize
\begin{alltt}
  \{
    "construct"   : "BitString"
    "name"        : "\emph{type name}",
    "width"       : \emph{number of bits}
  \}
\end{alltt}
\normalsize
The \code{name} field specifies the name of the newly defined type. The
name is formed of upper- and lower-case ASCII letters, digits, and dollar
signs (\code{A-Za-z0-9\$}).  It MUST begin with an upper case letter
(\code{A-Z}). Type names are defined in the global type namespace. 
It is an error to define the same type more than once.

The \code{width} field MAY be \code{null} in the JSON, to indicate that the
width is unspecified.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Arrays}

The array type constructor allows creation of types that represent a
sequence of elements of some other type that can be parsed or serialised.
The array type constructor is parameterised by the name of the new array
type, type of the elements it contains, and the length of the new array.
The length MAY be unspecified. 

An array has a single attribute, \code{length}, of type \code{Size}, that
denotes the number of elements contained. An array cannot contain elements
of its own type.

Arrays implement the \code{Equality} trait. Two arrays are equal if they
have the same element type, \code{length}, and their elements are equal.

Arrays implement the \code{IndexedCollection} trait. Elements are numbered from $0$ to
$\code{length}-1$.

In the JSON form of the intermediate representation, an invocation of the
array type constructor is represented as in the following:
\footnotesize
\begin{alltt}
  \{
    "construct"    : "Array",
    "name"         : "\emph{type name}",
    "element\_type" : "\emph{element type}"
    "length"       : \emph{number of elements}
  \}
\end{alltt}
\normalsize
The \code{name} field specifies the name of the newly defined type. The
name is formed of upper- and lower-case ASCII letters, digits, and dollar
signs (\code{A-Za-z0-9\$}).  It MUST begin with an upper case letter
(\code{A-Z}). Type names are defined in the global type namespace.
It is an error to define the same type more than once.

The \code{length} field MAY be \code{null} in the JSON, to indicate that
the length is unspecified.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Structure Types}

The structure type constructor allows creation of types that represent a
sequence of fields, with possibly different types, that can be parsed and
serialised. The structure type constructor is parameterised by the name of
the structure, details of the fields, and any constraints on the field
values.

In the JSON form of the intermediate representation, invocation of the type
constructor for a structure type is represented as in the following:
\footnotesize
\begin{alltt}
  \{
    "construct"   : "Struct"
    "name"        : "\emph{type name}",
    "fields"      : [
      \{
        "name"       : "\emph{field name}",
        "type"       : "\emph{field type}",
        "is\_present" : \emph{constraint}
      \},
      ...
    ],
    "constraints" : [
      ...
    ]
  \}
\end{alltt}
\normalsize
The \code{name} field specifies the name of the newly defined type. The
name is formed of upper- and lower-case ASCII letters, digits, and dollar
signs (\code{A-Za-z0-9\$}).  It MUST begin with an upper case letter
(\code{A-Z}). Type names are defined in the global type namespace.
It is an error to define the same type more than once.

The \code{fields} define the attributes of the new structure type. Each
field has a name, a type, and a constraint that indicates if the field is
present in a particular instantiation of the structure type. Structure
types MUST contain at least one field.

Each field has a name that is formed of upper and lower case ASCII letters,
digits, dollar signs, or underscores (\code{A-Za-z0-9\$\_}). The field name
MUST begin with a lower case letter (\code{a-z}).

Each field has a type. That type MUST have been previously defined, and can
be a \code{BitString}, array, structure type, or enumerated type. The names
of each field MUST be unique within a structure definition, but several
fields can have the same type.

Each field has a \emph{constraint}, \code{isPresent}, that indicates
whether that field is present in a particular instantiation of the
structure type. This is used to model data formats that contain optional
fields. Constraints are described in Section \ref{sec:constraints}.

Structures implement the \code{NamedCollection} trait. Its elements, \code{fields}, are
accessed by their \code{name}.

Finally, a structure type is parameterised by a set of constraints on the
fields. The set of constraints MAY be empty. Constraints are described in
Section \ref{sec:constraints}.

Both the per-field \code{isPresent} and struct-level \code{constraints} members MUST
only constraints that evaluate to Boolean types.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Context Types}

The context type constructor allows creation of types that represent a sequence of fields,
possibly of different types, that can be accessed in the parsing of other types, where
needed. The context type constructor is parameterised by the details of the fields it
includes.

In the JSON form of the intermediate representation, invocation of the type
constructor for a context type is represented as in the following:
\footnotesize
\begin{alltt}
  \{
    "construct"   : "Context"
    "fields"      : [
      \{
        "name"       : "\emph{field name}",
        "type"       : "\emph{field type}"
      \}
  \}
\end{alltt}
\normalsize

At most one context can be instantiated. If a context is instantiated, it is named
\code{\$Context} in the global type namespace. 

The \code{fields} define the attributes of the new structure type. Each
field has a name, a type, and a constraint that indicates if the field is
present in a particular instantiation of the structure type. Structure
types MUST contain at least one field.

Each field has a name that is formed of upper and lower case ASCII letters,
digits, dollar signs, or underscores (\code{A-Za-z0-9\$\_}). The field name
MUST begin with a lower case letter (\code{a-z}).

Each field has a type. That type MUST have been previously defined, and can
be a \code{BitString}, array, structure type, or enumerated type. The names
of each field MUST be unique within a structure definition, but several
fields can have the same type.

Contexts implement the \code{NamedCollection} trait. Its elements, \code{fields}, are
accessed by their \code{name}.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Enumerated Types}

The enumerated type constructor allows creation of types that represent
data that can exist as one of several possible variants when parsed or
serialised. The type constructor is parameterised by the name of the new
enumerated type, and the types of the variants.

In the JSON form of the intermediate representation, invocation of the type
constructor for an enumerated type is represented as in the following:
\footnotesize
\begin{alltt}
  \{
    "construct"   : "Enum"
    "name"        : "\emph{type name}",
    "variants"    : [
      \{"type" : "\emph{type name}"\},
      ...
    ]
  \}
\end{alltt}
\normalsize
The \code{name} field specifies the name of the newly defined type. The
name is formed of upper- and lower-case ASCII letters, digits, and dollar
signs (\code{A-Za-z0-9\$}).  It MUST begin with an upper case letter
(\code{A-Z}). Type names are defined in the global type namespace.
It is an error to define the same type more than once.

The \code{variants} field is an array that specifies the possible types
that variants of the enumerated type can take. These types MUST have been
previously defined, and the variants array MUST NOT be empty. Variants of
an enumerated type have their own types, but are otherwise unnamed.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Derived Types}

The derived type constructor allows creation of types as extensions of
existing types. A type derived in this way has the same representation
and properties as the type it is derived from, but has a new name and is
distinct from the original type. It can also implement additional traits.

The type constructor is parameterised by the name of the new derived type,
the base type from which it is derived, and a (possibly empty) list of any
additional traits the new type implements.

In the JSON form of the intermediate representation, invocation of the
type constructor for a derived type is represented as in the following:
\footnotesize
\begin{alltt}
  \{
    "construct"     : "NewType",
    "name"          : "\emph{type name}",
    "derived\_from"  : "\emph{type name}",
    "implements"    : [
      \{"trait" : "\emph{trait name}"\},
      \{"trait" : "\emph{trait name}"\}
    ]
  \}
\end{alltt}
\normalsize
The \code{name} field specifies the name of the newly defined type. The
name is formed of upper- and lower-case ASCII letters, digits, and dollar
signs (\code{A-Za-z0-9\$}).  It MUST begin with an upper case letter
(\code{A-Z}). Type names are defined in the global type namespace.

The \code{derivedFrom} field indicates the type from which the new type is
derived.  A new type can be derived from an existing \code{BitString},
array, structure type, or enumerated type. It is an error to define a new
type that has the same name as an existing type. A new type cannot be
derived from itself.

The \code{alsoImplements} field is an array that specifies any additional
traits that the new type implements compared to the base type. It is an
error to specify traits that are implemented by the base type.
The \code{alsoImplements} fields MAY be an empty array if the derived type
does not implement any additional traits compared to the base type.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Functions}
\label{sec:functions}

The function type constructor allows the definition of new function types,
giving the signature of a function to be provided by the implementation of
the protocol. The code comprising the body of the function is not specified. 

A function type has a name and a return type. It takes a number of
parameters, each of which has its own name and type. The return type
\code{Nothing} is used for functions that return no value.

Function names and parameter names are formed of upper and lower case ASCII
letters, digits, dollar signs, or underscores (\code{A-Za-z0-9\$\_}), and
MUST begin with a lower case letter (\code{a-z}).
Function names are defined in the global type namespace.

In the JSON form of the intermediate representation, invocation of the
function type constructor is represented as in the following:
\footnotesize
\begin{alltt}
  \{
    "construct"    : "Function"
    "name"         : "\emph{function name}",
    "parameters"   : [
      \{
        "name" : "\emph{parameter name}",
        "type" : "\emph{parameter type}"
      \},
      ...
    ],
    "return\_type"  : "\emph{return type name}",
  \}
\end{alltt}
\normalsize

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Protocols}

The protocol type constructor allows definition of new protocol types, that
describe the types and protocol data units (PDUs) that form a protocol. The
type constructor is parameterised by the name of the protocol, a set of
type definitions, and the set of PDUs used in the protocol.

In the JSON form of the intermediate representation, invocation of the
protocol type constructor is represented as in the following:
\footnotesize
\begin{alltt}
  \{
    "construct"   : "Protocol",
    "name"        : "\emph{protocol type name}",
    "definitions" : [
                      ...
                    ],
    "pdus"        : [
      \{"type" : "\emph{PDU type name}"\},
      \{"type" : "\emph{PDU type name}"\}
    ]
  \}
\end{alltt}
\normalsize
A protocol is the top-level object in the JSON form of the intermediate
representation.

The \code{name} field specifies the name of the newly defined type. The
name is formed of upper- and lower-case ASCII letters, digits, and dollar
signs (\code{A-Za-z0-9\$}).  It MUST begin with an upper case letter
(\code{A-Z}). Type names are defined in the global type namespace.

The \code{definitions} field that contains an array of objects representing
the types and functions used by the protocol. Any representable type, as
defined in Section \ref{sec:representable}, can be included.

The \code{pdus} field contains an array giving the type of the PDUs used
in the protocol. The PDUs array MAY be empty, although this represents a
protocol that is useless. PDUs can be any structure type or enumerated
type. 

%--------------------------------------------------------------------------------------------------
\subsection{Constraints}
\label{sec:constraints}

Contraints are split into two classes: leaf (\code{Constant} and \code{Field}) and tree
(\code{Equality}, \code{Ordinal}, \code{Boolean}, \code{Arithmetic}, and
\code{Conditional}). 

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Tree Constraints}

% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\textbf{\texttt{Equality}}

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Equality",
    "method"       : "\emph{name of any method of the}
                     Equality \emph{trait}",
    "left"         : \emph{constraint},
    "right"        : \emph{constraint}
  \}
\end{alltt}
\normalsize

The \code{Equality} constraint evaluates to the result of applying the \code{method} on
the \code{left} and \code{right} members.

Both the \code{left} and \code{right} members MUST be specified (as a constraint described
in this section), and MUST evaluate to types that implement \code{Equality} trait.

% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\textbf{\texttt{Ordinal}}

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Ordinal",
    "method"       : "\emph{name of any method of the}
                     Ordinal \emph{trait}",
    "left"         : \emph{constraint},
    "right"        : \emph{constraint}
  \}
\end{alltt}
\normalsize

The \code{Ordinal} constraint evaluates to the result of applying the \code{method} on
the \code{left} and \code{right} members.

Both the \code{left} and \code{right} members MUST be specified (as a constraint described
in this section), and MUST evaluate to types that implement \code{Ordinal} trait.

% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\textbf{\texttt{Boolean}}

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Boolean",
    "method"       : "\emph{name of any method of the}
                     BooleanOps \emph{trait}",
    "left"         : \emph{constraint},
    "right"        : \emph{constraint}
  \}
\end{alltt}
\normalsize

The \code{Boolean} constraint evaluates to the result of applying the \code{method} on
the \code{left} and \code{right} members.

Both the \code{left} and \code{right} members MUST be specified (as a constraint described
in this section), and MUST evaluate to types that implement \code{BooleanOps} trait.

% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\textbf{\texttt{Arithmetic}}

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Arithmetic",
    "method"       : "\emph{name of any method of the}
                     ArithmeticOps \emph{trait}",
    "left"         : \emph{constraint},
    "right"        : \emph{constraint}
  \}
\end{alltt}
\normalsize

The \code{Arithmetic} constraint evaluates to the result of applying the \code{method} on
the \code{left} and \code{right} members.

Both the \code{left} and \code{right} members MUST be specified (as a constraint described
in this section), and MUST evaluate to types that implement \code{ArithmeticOps} trait.

% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\textbf{\texttt{Conditional}}

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Conditional",
    "condition"    : \emph{constraint},
    "true"         : \emph{constraint},
    "false"        : \emph{constraint}
  \}
\end{alltt}
\normalsize

The \code{condition} MUST be a constraint that evaluates to the \code{Boolean} type.

The \code{Conditional} constraint evaluates to the \code{true} member, if \code{condition}
is \code{True}. Otherwise, the constraint evaluates to the \code{false} member.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Leaf Constraints}

% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\textbf{\texttt{Constant}}

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Constant",
    "type"         : "\emph{type name}",
    "value"        : \emph{value}
  \}
\end{alltt}
\normalsize

The \code{Constant} constraint evaluates to the \code{value} member, with type \code{type}.

% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\textbf{\texttt{Field}}

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Field",
    "accessor"     : \emph{NamedCollection getter}
  \}
\end{alltt}
\normalsize

The \code{Field} constraint evaluates to the field specified by the chain of
\code{accessor}s. The containing structure and, if it exists, \code{Context}, are in
scope.

The JSON form of a \code{NamedCollection} getter is:

\footnotesize
\begin{alltt}
  \{
    "key"          : "\emph{Key for NamedCollection}",
    "accessor"     : \emph{NamedCollection getter} or
                     \emph{IndexedCollection getter} or
                     \emph{null}
  \}
\end{alltt}
\normalsize

The JSON form of a \code{IndexedCollection} getter is:

\footnotesize
\begin{alltt}
  \{
    "index"        : \emph{Index for IndexedCollection},
    "accessor"     : \emph{NamedCollection getter} or
                     \emph{IndexedCollection getter} or
                     \emph{null}
  \}
\end{alltt}
\normalsize

\textbf{Example}

\footnotesize
\begin{alltt}
  \{
    "construct"    : "BitString",
    "name"         : "BitString1",
    "width"        : 1
  \}
  
  \{
    "construct"    : "Array",
    "name"         : "ArrayBitString1",
    "element_type" : "BitString1",
    "length"       : 10
  \}
  
  \{
    "construct"    : "Struct",
    "name"         : "StructTypeA",
    "fields"       : [\{"name": "fieldA", "type": "BitString1"\},
    				  \{"name": "fieldF", "type": "ArrayBitString1"\}],
    "constraints"  : null
  \}
  
  \{
    "construct"    : "Array",
    "name"         : "ArrayTypeA",
    "element_type" : "StructTypeA",
    "length"       : 4
  \}
  
  \{
    "construct"    : "Struct",
    "name"         : "StructTypeB",
    "fields"       : [\{"name": "fieldB", "type": "ArrayTypeA"\}, 
                      \{"name": "fieldC", "type": "BitString1"\},
                      \{"name": "fieldD", "type": "ArrayBitString1"\},
                      \{"name": "fieldE", "type": "StructTypeA"\}],
    "constraints"  : null
  \}
\end{alltt}
\normalsize

The JSON representation of a \code{Field} constraint that refers to \code{StructTypeB}'s
\code{fieldC} is:

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Field",
    "accessor"     : \{"key"     : "fieldC",
                       "accessor": null\}
  \}
\end{alltt}
\normalsize

The JSON representation of a \code{Field} constraint that refers to \code{fieldA} within
\code{StructTypeB}'s \code{fieldE} is:

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Field",
    "accessor"     : \{"key"     : "fieldE",
                       "accessor" : \{"key": "fieldA"\}\}
  \}
\end{alltt}
\normalsize

The JSON representation of a \code{Field} constraint that refers to the 2nd element of
\code{fieldF} within \code{StructTypeB}'s \code{fieldE} is:

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Field",
    "accessor"     : \{"key"     : "fieldE",
                      "accessor" : \{"key"      : "fieldF",
                      				 "accessor" : \{"index": 1, 
                      				                "accessor" : null\}\}
  \}
\end{alltt}
\normalsize

The JSON representation of a \code{Field} constraint that refers to the 5th element of
\code{StructTypeB}'s \code{fieldD} is:

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Field",
    "accessor"     : \{"key"      : "fieldD",
                       "accessor" : \{"index": 4, 
                      				  "accessor" : null\}\}
  \}
\end{alltt}
\normalsize

The JSON representation of a \code{Field} constraint that refers to the \code{fieldA}
within the 1st element of \code{StructTypeB}'s \code{fieldB} is:

\footnotesize
\begin{alltt}
  \{
    "constraint"   : "Field",
    "accessor"     : \{"key"     : "fieldB",
                      "accessor" : \{"index": 0, 
                      				 "accessor" : \{"key"      : "fieldA", 
                      				                "accessor" : null\}\}\}\}
  \}
\end{alltt}
\normalsize

%==================================================================================================
\section{Acknowledgements}

This work was supported by the Engineering and Physical Sciences Research
Council (grant EP/R04144X/1).

%==================================================================================================
\bibliographystyle{abbrvurl}
\bibliography{ir.bib}
%==================================================================================================
% The following information gets written into the PDF file information:
\ifpdf
  \pdfinfo{
    /Title        (The Glasgow Packet Language: Intermediate Representation and Execution Model)
    /Author       (Stephen McQuistin and Colin Perkins)
    /Subject      (The Glasgow Packet Language)
    /Keywords     (Parsing, Network Protocols, Packet Formats)
    /CreationDate (D:20180727162600Z)
    /ModDate      (D:20180727162600Z)
    /Creator      (LaTeX)
    /Producer     (pdfTeX)
  }
  % Suppress unnecessary metadata, to ensure the PDF generated by pdflatex is
  % identical each time it is built:
  \ifdefined\pdftrailerid
    % The \pdftrailerid and \pdfsuppressptexinfo macros were both introduced 
    % in pdfTeX 3.14159265-2.6-1.40.17. If one is present, the other will be.
    \pdftrailerid{}
    \pdfsuppressptexinfo=15
  \fi
\fi
%==================================================================================================
\end{document}
% vim: set ts=2 sw=2 tw=75 et ai:
