\documentclass[10pt]{article}
\usepackage[a4paper, total={6.5in, 11in}, includefoot, heightrounded]{geometry}
\usepackage{adjustbox}
\usepackage{array}
\usepackage{color}

\title{Literature Survey: Improving Protocol Standards for a more Trustworthy Internet}
\date{\today}

\newcommand{\todo}[1]{\textbf{\textcolor{red}{To do -- #1}}}
\newcommand{\paper}[3]{\vspace{4mm}\noindent\textbf{Paper:} ``\textit{#1}'' -- #2 \cite{#3}\vspace{3mm}}

\newcolumntype{R}[2]{%
    >{\adjustbox{angle=#1,lap=\width-(#2)}\bgroup}%
    l%
    <{\egroup}%
}
\newcommand*\rot{\multicolumn{1}{R{45}{1em}}}

\begin{document}
\maketitle

This document contains notes on the papers read as part of a literature survey for the
``\textit{Improving Protocol Standards for a more Trustworthy Internet}'' project.

%==============================================================================================

\section{Packet format definition languages}

One of the objectives of the project is to introduce (relatively simple) formalisms into
standards documents, such that tooling can be used to improve the quality of these
documents. One area where documents vary in quality, and that could easily be
improved by our proposed approach, is in the description of packet header formats. The
format used to describe these in standards documents varies, albeit slightly, complicating
their extraction and use by automated tools. Further, given that they are a common feature
in standards documents, any approach that allows for their specification to be simplified
(from the view of the author) is likely to be welcomed.

One approach to improving packet header definitions is through the use of a
domain-specific language (DSL). Such a DSL needs to allow the author to specify not only
the width and type of each field in the packet header, but also the relationships between
them, and any constraints that apply. The language must be accessible: it should reduce
the burden on the author, rather than adding additional complexity to the standards 
process.

The literature survey will cover not only languages specifically designed for packet
header definitions, but data format specification languages more generally. In addition,
architectural papers (i.e., those that don't define a language, but provide guidance) are
also in scope.

\subsection{Languages}

\paper{Packet Types: Abstract Specification of Network Protocol Messages}{McCann \& Chandra}{mccann2000packet}

McCann and Chandra propose PacketTypes, a packet specification language. Their motivation
is largely focussed on improving the efficiency with which packets can be parsed in
systems applications, though they note that the formal specification of packet formats is
likely to benefit standards specifications. They note that packet formats are fixed by
standards documents, and that implementing parsers is often complicated by the interaction
between different fields, and across the different layers. They use the IP header as an
example: the payload format is constrained by its own packet format, but this is
determined by the protocol field in the IP header. Further, the IP header contains a
variable-length options field; the length of this field is determined by the header length
field. More generally, they show that packet headers encapsulate sufficient complexity
that C's type system is insufficient. As a result, they develop PacketTypes: a
specification language for defining packet formats. They provide an implementation for
their language, and demonstrate its use by implementing a parser for Q.931 messages. 

PacketTypes has one primitive type, a \texttt{bit}. New types can be constructed using the
syntax \texttt{name := type}; for example, \texttt{byte := bit[8]} and
\texttt{bytestring := byte[]}. The square bracket operator (\texttt{[]}) is the same as
the Kleene star: here, a \texttt{bytestring} is comprised of zero or more bytes. Using
an integer inside the square brackets restricts the number of repetitions of the type to
be exactly that number -- so a \texttt{byte} is comprised of exactly 8 \texttt{bit}s.

Structures (e.g., packet headers) can be formed by grouping type definitions together.
From the paper, the IP packet can be defined as:
\begin{verbatim}
nybble := bit[4];
short := bit[16];
long := bit[32];
ipaddress := byte[4];
ipoptions := bytestring;

IP_PDU := {
  nybble       version;
  nybble       ihl;
  byte         tos;
  short        totallength;
  short        identification;
  bit          morefrags;
  bit          dontfrag;
  bit          unused;
  bit          frag_off[13];
  byte         ttl;
  byte         protocol;
  short        cksum;
  ipaddress    src;
  ipaddress    dest;
  ipoptions    options;
  bytestring   payload;
}
\end{verbatim}

While \texttt{IP\_PDU} defines the layout of an IP packet, without any constraints on the
values that each field can contain, by this definition alone, an invalid IP packet could
be constructed. PacketTypes allows a \texttt{where} clause to follow a type definition.
For example:

\begin{verbatim}
IP_PDU := {
  ...
} where {
  version#value = 0x04;
  options#numbytes = ihl#value * 4 - 20;
  payload#numbytes = totallength#value - ihl#value * 4;
}
\end{verbatim}

In this example, the \texttt{where} clause specifies that the IP version is 4, and defines
the size of the \texttt{options} and \texttt{payload} fields based on the \texttt{ihl}
and \texttt{totallength} fields. Note the introduction of new syntax here:
\texttt{field\#attribute} is used to refer to a particular attribute of a field. A number
of attributes are defined, including \texttt{value} (network-order concatenation of all
bits in the field), \texttt{numbits} (count of the number of bits in the field),
\texttt{numbytes} (count of the number of bytes in the field), \texttt{numelems} (count
of the number of elements in an array field), and \texttt{alt} (booleans indicating the
alternative chosen). In the absence of a constraints, the \texttt{[]} operator is greedy;
it is assumed that any data that could belong to that field does. It might be constrained
explicitly by the \texttt{where} clause, or implicitly, based on the length of the
structure that holds it.

A refinement operator, \texttt{:>} is defined. This is used to further constrain a type
that has already been specified. From the paper, an Ethernet frame could be specified as:

\begin{verbatim}
macaddr := bit[48];

Ethernet_PDU := {
  macaddr      dest;
  macaddr      src;
  short        type;
  bytestring   payload;
}
\end{verbatim}

Using a refinement, an IP packet within an Ethernet frame could be defined as:

\begin{verbatim}
IPinEthernet :> Ethernet_PDU where {
  type#value = 0x800;
  overlay payload with IP_PDU;
}
\end{verbatim}

This specifies the type as \texttt{0x800}, and overlays the \texttt{IP\_PDU} definition
above on top of the Ethernet payload. The \texttt{overlay .. with} syntax embeds one type
within the other, reflecting protocol encapsulation. Here, the constraints of the
\texttt{IP\_PDU} definition are applied to the \texttt{payload} field of
\texttt{Ethernet\_PDU}; for a packet to be a valid \texttt{IPinEthernet} packet, its
Ethernet header must have \texttt{type} equal to \texttt{0x800}, and a payload that is a
valid \texttt{IP\_PDU} packet.

PacketTypes includes dot notation syntax to allow the fields in the overlaid structure to
be accessed:

\begin{verbatim}
My_IPinEthernet :> IPinEthernet where {
  payload.srcaddr#value = 192.168.0.1;
}
\end{verbatim}

In this example, the \texttt{payload} is the \texttt{Ethernet\_PDU} payload; the dot
notation allows for the \texttt{srcaddr} of the overlaid \texttt{IP\_PDU} definition to be
accessed, and here, have its value specified.

Alternative types can be specified using the alternation operator, \texttt{|=}. This
combines types disjunctively -- a bitstring matches the defined type if it matches one of
the alternatives. As an example, the paper gives a more precision definition of the
\texttt{ipoptions} type:

\begin{verbatim}
ipoptions := {
  NonEndOption     neo[];
  EndOption        eo;
  bytestring       padding;
} where {
  eo#numelems <= 1;
}
\end{verbatim}

By this definition, IP options are comprised of a zero or more \texttt{NonEndOption}s,
followed by an optional (zero or one) \texttt{EndOption}, and padding.
\texttt{NonEndOption}s make use of the alternation operator:

\begin{verbatim}
NonEndOption |= {
  NoOperation     nop;
  Security        sec;
  LSRR            lsrr;
  SSRR            ssrr;
  RR              rr;
  StreamID        sid;
  Timestamp       tstamp;
}
\end{verbatim}

The \texttt{|=} means that a bitstring is a \texttt{NonEndOption} if and only if it is one
of the alternative types given. The \texttt{\#alt} attribute can be used in the
\texttt{where} clause to determine which alternative was matched. Boolean expressions can
be constructed; for example \texttt{neo[0]\#alt @ nop} is true if the first
\texttt{NonEndOption} in the IP options field is a \texttt{NoOperation}. Note the use of
the \texttt{@} operator here.

Constraints in the \texttt{where} clause can be expressed using relational operators and
boolean combinators:
\begin{verbatim}
          = > < >= <= != || && + * / -
\end{verbatim}

PacketTypes limits, for computability, the possible set of constraints. Constraints that
specify the size of variable-sized fields must only reference attributes that have already
been specified. The authors allow particular implementations to further limit
constraints.

\paper{Melange: Creating a ``Functional'' Internet}{Madhavapeddy et al.}{madhavapeddy2007melange}

The motivation for Melange is centres on the widespread use of type-unsafe languages (like
C and C++) in network system implementations, exposing such systems to security and
reliability issues. Melange combines two techniques to eliminate the perceived performance
impact of type-safe languages, allowing for their use in implementing Internet protocols:
a strong, static type system, and generative meta-programming. Of interest here is their
domain-specific language, Meta Packet Language (MPL).

The authors provide the Extended BNF grammar for MPL:

\begin{verbatim}
main -> (packet-decl)+ EOF
packet-decl -> packet identifier[(packet-args)] packet-body
packet-args -> {int | bool} identifier [, packet-args]
packet-body -> {(statement)+}
statement -> identifier : identifier [var-size] (var-attr)*;
           | classify (identifier) {(classify-match)+};
           | identifier : array(expr) {(statement)+};
           | ();
classify-match -> '|' expr : expr[when (expr)] -> (statement)+
var-attr -> variant {('|' expr {->|=>} cap-identifier)+}
          | {min|max|align|value|const|default} (expr)
var-size -> [expr]
expr -> integer | string | identifier | (expr)
      | expr {+|-|*|/|and|or} expr
      | {-|+|not} expr
      | true | false
      | expr {>|>=|<|<=|=|..} expr
      | {sizeof|array_length|offset} (expr-arg)
      | remaining()
\end{verbatim}

A simple specification in MPL consists of an ordered list of named \emph{typed} fields.
Types can be: (i) wire types (network representation of the field); (ii) MPL types (used
within the specification -- strings in the grammar above); or (iii) language types (used
in target language -- i.e., the language that the MPL is compiled to). Wire types are
mapped to MPL types, allowing these types to be used as part of the specification.
Additionally, every wire type has a corresponding language type. 

The grammar includes the \texttt{classify} keyword, to allow for parsing decisions to
depend on the contents of another field (so long as that field has already been defined).
Fields have attributes; these can be constraints that define the maximum or minimum value,
a default value, or a constant value, among others. 

As an example, the authors provide an MPL specification of IPv4:

\begin{verbatim}
packet ipv4 {
  version: bit[4] const(4);
  ihl: bit[4] min(5) value(offset(options) / 4);
  tos_precedence: bit[3] variant {
    |0 => Routine
    |1 -> Priority
    |2 -> Immediate
    |3 -> Flash
    |4 -> Flash_override
    |5 -> ECP
    |6 -> Inet_control
    |7 -> Net.control
  };
  delay: bit[1] default(false);
  throughput: bit[1] default(false);
  reliability: bit[1] default(false);
  reserved: bit[2] const(0);
  length: uint16 value(offset(data));
  id: uint16;
  reserved: bit[1] const(0);
  dont_fragment: bit[1] default(0);
  can_fragment: bit[1] default(0);
  frag_off: bit[13] default(0);
  ttl: byte;
  protocol: byte variant {
   |1 -> ICMP
   |2 -> IGMP
   |6 -> TCP
   |17 -> UDP
  };
  checksum: uint16 default(0);
  src: uint32;
  dest: uint32;
  options: byte[(ihl * 4) - offset(dest)] align(32);
  header_end: label;
  data: byte[length-(ihl*4)];
}
\end{verbatim}

\paper{PADS: A Domain-Specific Language for Processing Ad Hoc Data}{Fisher and Gruber}{fisher2005pads}

Processing Ad hoc Data Sources (PADS) is a declarative data description language for
describing the layout and semantic properties of \emph{ad hoc} data. Ad hoc, in this
context, refers to data formats that are stored in (previously) ill-defined, non-standard
formats. This in contrast to data stored in database systems, or described using a
structured language (e.g., XML). The authors cite examples of such data: call logs, web
server access logs, etc. While much of the motivation for PADS does not apply here (i.e.,
we are not describing ad hoc data), of interest is the motivation that runs through most
of the papers in this document: parsers are tedious to write, and the process is
error-prone. A formal or structured description of the data is desirable to improve this
situation.

The PADS description language is typed-based, with atomic base types for 32-bit integers
(\texttt{Pint32}), strings (\texttt{Pstring}), and IP address (\texttt{Pip}), among
others. These types are augmented with information about how the data is coded (e.g., in
ASCII or binary). PADS interprets the types as ASCII by default, but this can be specified
by using the appropriate base type: for example, \texttt{Pa\_int32} is an \emph{ASCII}
32-bit integer, \texttt{Pb\_int32} is a \emph{binary} 32-bit integer. Users can specify
their own base types.

PADS includes structured types, akin to C's types: \texttt{Pstruct} (structures),
\texttt{Punion} (alternatives), and \texttt{Parray} (sequences), \texttt{Penum} (fixed set
of literals), \texttt{Popts} (optional data). Each of these can have a predicate
associated with it, to indicate whether a parsed value is a legal value for the type. For
example, a predicate might specify that two fields of a \texttt{Pstruct} are related, or
that a sequence is in increasing order. These predicates are specified using C-like
syntax. Further constraints can be added to existing types using \texttt{Ptypedef}. PADS
types may be parameterised by values. For example, \texttt{Pstring(:' ':)} defines a
string terminated by a space. 

\paper{DataScript: A Specification and Scripting Language for Binary Data}{Back}{back2002datascript}

Back describes DataScript, a language for the specification and manipulation of binary
data formats, using types. It consists of two components: a constraint-based specification
language (that uses DataScript types), and a language binding that provides a simple
scripting interface. The motivation for DataScript is that natural language prose is not
well suited to describing the design of binary data formats: not only is it inefficient,
but it can introduce ambiguities that translate into bugs in implementations. 

A DataScript type can be either: (i) a primitive type; (ii) a set type (an enumerated
or bitmask type); (iii) a linear array (of another type); or (iv) a composite (record or
variant-record) type.

Primitive types form the basis for more complicated types. These types include bit fields,
bytes, and variable length integers. Primitive types are interpreted as signed or unsigned
integers, with the size and signedness specified in the keyword (e.g., uint32, int16). For 
multi-byte integers, endianness is specified using an optional attribute prefix:
\texttt{little} or \texttt{big}. Where this isn't specified, the default is big endian 
(i.e., network byte order).

Two set types are supported: enumerated types (\texttt{enum}) and bitmask types
(\texttt{bitmask}). A set type constrains an underlying primitive type, specifying the
signedness and endianness, used to store and interpret its values. For example, it can be
used to specify the valid values of a bitfield.

Composite types are specified using a C-like language, and this follows from the
interpretation of these types: they are similar to C structs and unions. Unions in
DataScript are discriminated/tagged, taking the first matching constraint in the union --
the order in the specification is important. The constraints don't need to be disjoint,
allowing for default choices. Composite types can be nested, with scoping rules that
provide a namespace for each type.

DataScript arrays are linear, with integer indices, and specified lower and upper
bounds (\texttt{[lower.. upper]}; lower is a valid indice, upper is not); lower, if
omitted defaults to 0. Expressions specifying bounds must be able to be evaluated at the
time that the array is read (i.e., be based on a previously defined field). 

Fields can have constraints, specified as a boolean predicate. Constraints are used in
three ways: (i) to discriminate union types; (ii) express consistency requirements in
record types; and (ii) limit the length of array types, where the length is not known;
arrays can grow until their constraints are violated. Predicates are boolean expressions,
with DataScript adopting the operators, associativity, and precedence rules from Java and
C. 

\paper{P4: Programming protocol-independent packet processors}{Bosshart et al.}{bosshart2014p4}

P4 is a high-level language, designed for programming packet processors (e.g., switches).
The goals of P4 are to allow for easy reconfigurability of switches once deployed,
the development of an abstraction to allow switches to be protocol agnostic, and a further
abstraction to allow the programming of switches to be independent of the underlying
hardware. While this goals are very different to those of this project, they lead to the
development of a programming language that has many desirable features.

A P4 program is comprised of five components:
\begin{itemize}
\item \textbf{Headers} The sequence and structure of packets
\item \textbf{Parsers} Definition of how headers should be identified and validated
\item \textbf{Tables} Packet matching tables for packet processing
\item \textbf{Actions} Triggered by matching a table entry
\item \textbf{Control Programs} Defines ordering and flow between matching (and action) entries
\end{itemize}

Of these, header definitions are of interest. These are specified by declaring an ordered
list of field names, together with their bit widths. For example, the Ethernet header is
specified as:

\begin{verbatim}
  header ethernet {
    fields {
      dst_addr : 48; // width in bits
      src_addr : 48;
      ethertype : 16;
    }
  }
\end{verbatim}

[Note: the P4 paper doesn't focus on the header specification language; the P4 manual is
a better resource. The language has also changed considerably since this paper]

\paper{Abstract Syntax Notation One (ASN.1): Specification of basic notation}{ITU-T (Information technology)}{x680}

ASN.1 is a language for defining the structure of data. It includes a number of simple
data types, and notation for referencing and specifying values for these. Importantly,
this notation does not constrain the encoding format for the data being specified. This
is handled by supplementary encoding rules: the ``transfer syntax'' -- e.g., Basic
Encoding Rules (BER), or Packed Encoding Rules (PER). The focus here is on the abstract
notation, and the semantics it supports.

ASN.1 supports the general technique of defining a small core of simple types, and
allowing these to be combined in various ways to define new types. These new types can
be defined, for example, by composing an ordered sequence of the existing types, or using
other structures or relationships. To allow for the unambiguous encoding of these types,
they are assigned a tag: these are helpers for parsers of the language, rather than for
human readers.

An instance of the ASN.1 notation (defining types, values, sets, etc) is a
module. Modules definitions being with this syntax:

\begin{verbatim}
  ModuleIdentifier DEFINITIONS ::= BEGIN
\end{verbatim}

Modules contain type definitions:

\begin{verbatim}
  ModuleIdentifier DEFINITIONS ::= BEGIN
      TypeIdentifier ::= SEQUENCE {
          label     INTEGER,
          label2    BOOLEAN
      }
  END
\end{verbatim}

ASN.1 allows for values to be constrained:

\begin{verbatim}
  ModuleIdentifier DEFINITIONS ::= BEGIN
      TypeIdentifier ::= SEQUENCE {
          label     INTEGER(0..15),
          label2    BOOLEAN
      }
  END  
\end{verbatim}

Additionally, definitions can be reused and extended:

\begin{verbatim}
  ModuleIdentifier DEFINITIONS ::= BEGIN
      TypeIdentifier ::= SEQUENCE {
          label     INTEGER,
          label2    BOOLEAN
      }
    
      TypeIdentiferExtension ::= SEQUENCE {
          label3    SEQUENCE OF TypeIdentifier,
          ...
      }
  END
\end{verbatim}

The ``..'' is part of the language: it says that the TypeIdentifierExtension specification
might contain additional fields in later versions.

\paper{A language-based approach to protocol construction}{Basu et al.}{basu1997language}

Basu et al. describe Promela++, an extension to the Promela protocol validation language.
Promela++ adds constructs for specifying layered protocols and for composing these
protocols into a stack. In addition, it provides support for the encapsulation of
protocol state, and message headers. Again, the focus here is on the language itself, and
the semantics it supports, rather than on the tooling that is described alongside it.

Promela++ is syntactically similar to C, but with a number of modifications and
constraints. Importantly, Promela++ separates the lower-level network access and data
handling components from the protocol-layer control structures. This has a number of
advantages, allowing the low-level components to be hidden from the protocol-level
validator.

In Promela++, a protocol layer is comprised of user-defined types that encapsulate the
state of the protocol layer, and the message header used by the protocol layer. These
are flagged using the \texttt{state} and \texttt{message} keywords respectively. Of 
interest here is the message header defintion language.

Message headers are expressed as:

\begin{verbatim}
  message UAM_msg {
    UAM_short        am,
    ...
  };
\end{verbatim}

\paper{CSN. 1 Specification, Version 2.0}{Mouly}{mouly1998csn}

The Concrete Syntax Notation, CSN.1, is a language that was introduced by 3GPP, to aid in
the description of the \emph{encoded} format of layer 3 GSM messages. Previously, these
messages were described with various ad hoc methods, including textual descriptions of the
meaning of each bit. The goals of CSN.1, then, are to unify the way in which these
messages are described, using a formal language, and in so doing, encourage the
development of tooling that could generate encoding/decoding programs.

CSN.1 operates over a logical bit stream, of arbitrary length. A CSN.1 definition
describes the transmission syntax, defining which sequences of bits are valid. In
addition, components of the bit stream are labelled. However, CSN.1 does not allow for any
relationships between these different components to be modelled. The meaning of each value
is not defined; no attempt is made to constrain a given message to carry a set of values
that all make sense together.

As an example:

\begin{verbatim} < TEST > ::= 00001111; \end{verbatim}

Here, \texttt{TEST} has a fixed value (15).

\begin{verbatim} < TEST_OR > ::= 0000 {1111 | 0000}; \end{verbatim}

In this example, \texttt{TEST\_OR} can take on two possible (8-bit) values: 0 or 15.
However, there is no notation to define when \texttt{TEST\_OR} should take on either of
those values: that is entirely application dependent, and cannot be modelled here.

\subsection{Packet parser design principles}
\paper{Design principles for packet parsers}{Gibb et al.}{gibb2013design}

In this paper, the authors discuss the design tradeoffs present in packet parsers, and
identify the design principles that exist. Additionally, they describe a parser generator.
As part of this parser generator, a language to describe packet formats is defined.
As an example, the IPv4 header is described as:

\begin{verbatim}
  ipv4 {
    fields {
      version        :  4,
      ihl            :  4,
      diffserv       :  8 : extract,
      totalLen       : 16,
      identification : 16,
      flags          :  3 : extract,
      fragOffset     : 13,
      ttl            :  8 : extract,
      protocol       :  8 : extract,
      hdrChecksum    : 16,
      srcAddr        : 32 : extract,
      dstAddr        : 32 : extract,
      options        : *,
    }
    next_header = map(fragOffset, protocol) {
       1 : icmp,
       6 : tcp,
      17 : udp,
    }
    length = ihl * 4 * 8
    max_length = 256
  }
\end{verbatim}

This description includes the name and size of each field, a label for fields that should
be extracted, a mapping between field values, and for variable-length headers, a
definition of length derived from field values.

\todo{Expand}

\paper{Writing parsers like it is 2017}{Chifflier and Couprie}{chifflier2017writing}

In this paper, the authors present a Rust-based combinator approach to parser design. This
is motivated by the prevalence of memory corruption bugs in parsers implemented in
low-level languages. Many of the issues raised by the authors result from the use of
unsafe languages, such as C, for parser implementation, and they recommend changing to a 
safe language, such as Rust, to solve many of these.

\todo{Expand}

\subsection{Network protocol DSLs \& motivation}

\paper{Domain specific languages (DSLs) for network protocols}{Bhatti et al.}{bhatti2009domain}

\todo{Write up notes}

\paper{The Bugs We Have to Kill}{Bratus et al.}{bratus2015bugs}

\todo{Read and write up}

\subsection{Summary}

\begin{tabular}{ l | r r r r r }
  Language/Feature & \rot{Primitive types} & \rot{Composite types} & \rot{Value constraints} & \rot{Inheritance} & \rot{Derived properties} \\   \hline			
  PacketTypes      & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
  Melange          & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & \\
  PADS             & $\bullet$ & $\bullet$ & $\bullet$ & & \\
  DataScript       & $\bullet$ & $\bullet$ & $\bullet$ & &  \\
  P4               & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
  ASN.1            & $\bullet$ & $\bullet$ & $\bullet$ & & \\
  Promela++        & $\bullet$ & $\bullet$ & $\bullet$ & & \\
  CSN.1            & $\bullet$ & $\bullet$ & & & \\    
  \hline  
\end{tabular}

%==============================================================================================

\section{Parsing IETF protocols}

In this section, we look at the features required of a packet format definition language,
when describing the syntax of various IETF protocols. Such a language must allow for a
parser to be generated based upon the definition: enough information should be available
to validate the syntax of a given packet, against the definition. To do this, we use the
concept of \emph{contexts}. The parsing process makes use of two contexts: a per-packet
context, and a per-flow context. Contexts contain information from other, earlier fields
(in the case of the per-packet context) or from other, earlier packets (in the case of the
per-flow context) \emph{that is necessary to parse other fields}. The per-packet context
contains the values of earlier fields, and these can be used to constrain the value or
properties of later fields. For example, an IP header has a \texttt{version} field; the
value of this field determines the layout of the packet. The per-flow context can be
added to by the parser, acting on earlier packets, or by an out-of-band process. These
values can be used to constrain the value or properties of fields in later packets. The
per-flow context is particularly useful for cryptographic protocols, where a key is
provided as part of a message exchange earlier in the flow (or out-of-band).

It is important to note here that it is easy to see that these contexts could be used to
enforce semantic properties of packets, rather than the syntactic validation that parsing
requires. For example, the per-flow context might be used to determine that packets
out-of-sequence are invalid. However, this is out-of-scope: constraints on packet values,
based on data from contexts, should only be used for parsing -- that is, to determine if
a packet's format is valid, rather than determining if the contexts of each field are
valid.

\subsection{IP}

The IP header is comprised of a 4 bit \texttt{version} field. The rest of the header's
format is determined by the value of this field.

\subsubsection*{IPv4}

An IPv4 header has the following fields:
\begin{itemize}
\item \texttt{IHL}: 4 bits
\item \texttt{DiffServ}: 6 bits
\item \texttt{ECN}: 2 bits
\item \texttt{Total Length}: 16 bits
\item \texttt{Identification}: 16 bits
\item \texttt{Flags}: 3 bits
\item \texttt{Offset}: 13 bits
\item \texttt{TTL}: 8 bits
\item \texttt{Protocol}: 8 bits
\item \texttt{Checksum}: 16 bits
\item \texttt{Source Addr}: 32 bits
\item \texttt{Dest Addr}: 32 bits
\item \texttt{Options}: variable length (incorporates padding to 32 bit boundary)
\item \texttt{Payload}: variable length
\end{itemize}

Constraints:
\begin{itemize}
\item The length of the Options field depends on the IHL field:
\texttt{len(Options) = IHL*4 - 20} (where the length is in bytes).
\item The Options field contains zero or more variable length Options, with their own
sub-format:
\begin{itemize}
\item \texttt{Copy} 1 bit
\item \texttt{Class} 2 bits
\item \texttt{Number} 5 bits
\item \texttt{Length} 8 bits
\item \texttt{Data} variable length
\end{itemize}
The number of Options is constrained both by the length of the field, and by the length
of each Option. The Options field needs to pad to a 32 bit boundary. Further, the
header can be at most 60 bytes long, leaving a maximum of 40 bytes for the Options field.
\item The value of the Protocol field determines how the Payload field should be parsed.
\end{itemize}

Notes:
\begin{itemize}
\item The DiffServ and ECN fields were originally specified as a single 8 bit 
Type of Service (ToS) field. How should a definition language support changes in
specification, where those changes happen between different documents?
\item Parsing the Options field is interesting: it contains a zero or more variable
length Options. The definition language should support sequences of this type, where the
length of the sequence can only be determined by parsing each element in turn.
\end{itemize}

\subsubsection{IPv6}

An IPv6 header has the following fields:
\begin{itemize}
\item \texttt{Traffic Class}: 8 bits
\item \texttt{Flow Label}: 20 bits
\item \texttt{Payload Length}: 16 bits
\item \texttt{Next Header}: 8 bits
\item \texttt{Hop Limit}: 8 bits
\item \texttt{Source Addr}: 128 bits
\item \texttt{Dest Addr}: 128 bits
\item \texttt{Payload}: variable length
\end{itemize}

Constraints:
\begin{itemize}
\item The value of the Next Header field determines how the Payload field should be parsed.
\end{itemize}

Notes:
\begin{itemize}
\item IPv6 headers don't have an Options field. Extension headers play much the same role,
but these are handled in a much cleaner way: they are chained onto the IPv6 header using
the Next Header field (with the chain ending with a upper-layer protocol, or a No Next
Header value). While extensions to the IPv6 protocol, for parsing, it makes sense to treat
them as a separate upper-layer protocol.
\end{itemize}

\subsection{UDP}

A UDP header has the following fields:
\begin{itemize}
\item \texttt{Source Port}: 16 bits
\item \texttt{Dest Port}: 16 bits
\item \texttt{Length}: 16 bits
\item \texttt{Checksum}: 16 bits
\item \texttt{Payload}: variable length
\end{itemize}

Notes:
\begin{itemize}
\item The UDP header is straightforward; no constraints based on other fields or earlier packets.
\end{itemize}

\subsection{TCP}

A TCP header has the following fields:
\begin{itemize}
\item \texttt{Source Port}: 16 bits
\item \texttt{Dest Port}: 16 bits
\item \texttt{Sequence Number}: 32 bits
\item \texttt{ACK Number}: 32 bits
\item \texttt{Data Offset}: 4 bits
\item \texttt{Reserved}: 3 bits
\item \texttt{Flags}: 9 bits
\item \texttt{Window Size}: 16 bits
\item \texttt{Checksum}: 16 bits
\item \texttt{URG Pointer}: 16 bits
\item \texttt{Options}: variable length (incorporates padding to 32 bit boundary)
\item \texttt{Payload}: variable length
\end{itemize}

Constraints:
\begin{itemize}
\item The length of the Options field depends on the Data Offset field:
\texttt{len(Options) = Data Offset - 5} (where the length is in 32-bit words).
\item The Options field contains zero or more variable length Options, with their own
sub-format:
\begin{itemize}
\item \texttt{Option-Kind} 8 bits
\item \texttt{Option-Length} 8 bits
\item \texttt{Option-Data} variable length
\end{itemize}
The number of Options is constrained both by the length of the field, and by the length
of each Option. The Options field needs to pad to a 32 bit boundary. Further, the header
can be at most 60 bytes; leaving a maximum of 40 bytes for the Options field.
\end{itemize}

\subsection{DCCP}

A DCCP header has the following fields:
\begin{itemize}
\item \texttt{Source Port}: 16 bits
\item \texttt{Dest Port}: 16 bits
\item \texttt{Data Offset}: 8 bits
\item \texttt{CCVal}: 4 bits
\item \texttt{CsCov}: 4 bits
\item \texttt{Checksum}: 16 bits
\item \texttt{Res}: 3 bits
\item \texttt{Type}: 4 bits
\item \texttt{eXtended Sequence Number Flag}: 1 bit
\item \texttt{Reserved}: 0 (X=1) or 8 (X=0) bits
\item \texttt{Sequence Number}: 48 (X=1) or 24 (X=0) bits
\item \texttt{Payload}: variable length
\end{itemize}

Constraints:
\begin{itemize}
\item The layout of the packet after the X field depends on its value; if X=1, then there
is an 8 bit Reserved field, followed by an extended, 48 bit, sequence number. If X=0, then
there is no Reserved field, and the sequence number is 24 bits.
\end{itemize}

\subsection{SCTP}

An SCTP header has the following fields:
\begin{itemize}
\item \texttt{Source Port}: 16 bits
\item \texttt{Dest Port}: 16 bits
\item \texttt{Verification Tag}: 32 bits
\item \texttt{Checksum}: 32 bits
\item \texttt{Payload}: variable number of variable-length chunks
\end{itemize}

Notes:
\begin{itemize}
\item The payload is in the form of chunks, which have the following format:
\begin{itemize}
\item \texttt{Chunk Type}: 8 bits
\item \texttt{Chunk Flags}: 8 bits
\item \texttt{Chunk Length}: 16 bits
\item \texttt{Chunk Data}: variable length (padded to 32 bit boundary)
\end{itemize}
\item Chunk formats are standardised; again, any definition language used would need to
support this type of extensibility. 
\item There are a variable number of chunks, of variable length, so the number of chunks
is not known before they are parsed.
\end{itemize}

\subsection{QUIC}

QUIC has two header types: long (for packets sent before version negotiation) and short
(after version negotiation). The most significant bit in the first octet determines
whether the header is long (=1) or short (=0).

The long header has the following format:
\begin{itemize}
\item \texttt{Header Form}: 1 bit (set to 0)
\item \texttt{Long Packet Type}: 7 bits
\item \texttt{Version}: 32 bits
\item \texttt{Destination Connection ID Length}: 4 bits
\item \texttt{Source Connection ID Length}: 4 bits
\item \texttt{Destination Connection ID}: 0 or 32 to 144 bits
\item \texttt{Source Connection ID}: 0 or 32 to 144 bits
\item \texttt{Payload Length}: variable length integer
\item \texttt{Packet Number}: 32 bits
\item \texttt{Payload}: variable length
\end{itemize}

Constraints:
\begin{itemize}
\item The Destination and Source Connection ID fields have their length defined by the
Destination and Connection ID Length fields. The length fields are encoded as 4-bit
unsigned integers; if they are zero, then the connection ID fields are zero. However, if
they are non-zero, then the related connection ID field this value plus 3. As a result,
the length is either 0, or between 32 to 144 bits. The packet header specification
language needs to be able to express this logic.
\item The payload length field is a variable length integer. This field is either 1, 2,
4, or 8 octets long, depending on the value of the two most significant bits of the first
octet (they encode the base 2 logarithm of the length of the field). The remaining bits
are used to encode the value.
\end{itemize}

The short header has the following format:
\begin{itemize}
\item \texttt{Header Form}: 1 bit (set to 0)
\item \texttt{Key Phase Bit}: 1 bit
\item \texttt{Third Bit}: 1 bit (set to 1)
\item \texttt{Fourth Bit}: 1 bit (set to 1)
\item \texttt{Google QUIC Demultiplexing Bit}: 1 bit (set to 0)
\item \texttt{Reserved}: 1 bit
\item \texttt{Short Packet Type}: 2 bits
\item \texttt{Destination Connection ID}: 0 to 144 bits
\item \texttt{Packet Number}: 8, 16, or 32 bits
\item \texttt{Protected Payload}: variable length
\end{itemize}

Constraints:
\begin{itemize}
\item The Destination Connection ID is the Source Connection ID received by the endpoint.
Given that this is a variable length field, it can only be parsed if we have the 
Source Connection ID Length field received earlier in the flow (as part of the long
header). 
\item The Packet Number field is either 8, 16, or 32 bits, depending on the value of the
short packet type field.
\item The Protected Payload field is protected using authenticated encryption. The key is
derived from the TLS handshake. The nonce, however, is formed from the packet protection
invariant, and the packet number. The packet number carried in the packet, though, carries
only the least significant bits of the full packet number needed for determining the
cryptographic nonce. Therefore, the parser must keep track of the highest sequence
number successfully authenticated.
\end{itemize}

\subsubsection*{Version Negotiation packet}

The version negotiation packet format is:
\begin{itemize}
\item \texttt{Header Form}: 1 bit (set to 1)
\item \texttt{Unused}: 7 bits
\item \texttt{Version}: 32 bits
\item \texttt{Destination Connection ID Length}: 4 bits
\item \texttt{Source Connection ID Length}: 4 bits
\item \texttt{Destination Connection ID}: 0 or 32 to 144 bits
\item \texttt{Source Connection ID}: 0 or 32 to 144 bits
\item \texttt{Supported Versions}: 1 or more 32 bit fields
\end{itemize}

Notes:
\begin{itemize}
\item This is not the long header format, but it does have the same value for the first
bit. Therefore, this bit alone is not sufficient to determine how the packet should be
parsed: the Version field must be set to 0.
\end{itemize}

\subsection{RTP}

\footnotesize
\begin{verbatim}
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                     [CSRC identifier list]                    |
   |                        (4 * CC octets)                        |
   |                         CC may be zero                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -+
   |     defined by signalling     |    header extension length    |  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
   |                       header extension                        |  | OPTIONAL
   |                 format defined by signalling                  |  | (if X=1)
   |                                                               |  |
   |                                                               |  |
   |                                                               |  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -+
   |                           Payload                             |
   |           (variable format and length, depends on PT)         |
   |                                                               |
   |                                                               |
   |                                                               |
   |               +-------.........---------------+---------------+
   |               |Padding (PadCnt octets, if P=1)|PadCnt (if P=1)|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}
\normalsize

\begin{itemize}
  \item Some fields are optional, and signalled by the value of earlier 
        header fields
  \item Format of some fields depends on the value of earlier header fields,
        with the meaning of those earlier fields being signalled out-of-band
  \item Presence and length of some fields depends on later fields
\end{itemize}

Format of the header extension needs to be signalled in SDP. The only
standard format is RFC5285:

\footnotesize
\begin{verbatim}
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            0xBEDE             |    header extension length    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  ID   | L=0   |     data      |  ID   |  L=1  |   data...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         ...data   |    0 (pad)    |    0 (pad)    |  ID   | L=3   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          data                                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}
\normalsize

\begin{itemize}
  \item 0xBEDE (``the first version of this specification was written on
    the feast day of the Venerable Bede'').
  \item ID values define the type of extension, meaning signalled out of 
    band
  \item L is length of following data
  \item L+1 data bytes follow
  \item ID=0, L=0 is a single byte of padding and is ignored
  \item MUST pad to a 32 bit boundary
\end{itemize}

There's also a variant where ID and L are one octet each, and the first 16
bits of the header are:
\footnotesize
\begin{verbatim}
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         0x100         |appbits|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}
\normalsize
where \verb|appbits| are 4 bits that ``are application dependent and MAY be
defined to be any value or meaning; this topic is outside the scope of this
specification''.

\subsection{RTCP}

\footnotesize
\begin{verbatim}
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|   XXX   |       PT      |             length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              YYY                              |
   |                       (length * 4 octets)                     |
   |                                                               |
   |                                                               |
   |                                                               |
   |                                                               |
   |               +-------.........---------------+---------------+
   |               |Padding (PadCnt octets, if P=1)|PadCnt (if P=1)|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}
\normalsize

\begin{itemize}
  \item  Meaning of XXX and YYY depends on PT. This implies that the
    meaning of a field depends on the value of a later field
  \item RTCP packets are often sent as a \emph{compound packet} where
    multiple RTCP packets are stacked into a single UDP packet. There
    are several rules about how this is done:
    \begin{itemize}
      \item The first packet in the compound packet MUST be an SR or RR.
        If there are additional RR packets, they SHOULD follow the initial
        SR/RR packet.
      \item The compound packet MUST include an SDES packet, and that SDES 
        packet MUST include a CNAME item.
      \item If padding is added, it MUST only be added to the last RTCP
        packet in the compound packet. That is, P=0 on all but the last
        packet. 
    \end{itemize}
\end{itemize}

Of the packet types defined in RFC 3550, only the SDES is complex:

\footnotesize
\begin{verbatim}
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    SC   |  PT=SDES=202  |             length            |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
chunk  |                          SSRC/CSRC_1                          |
  1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
chunk  |                          SSRC/CSRC_2                          |
  2    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
\end{verbatim}
\normalsize

where \verb|SC| is the count of the number of chunks. Each chunk comprises
a list of items, where the format of an item is:
\footnotesize
\begin{verbatim}
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |      type     |     length    |           value...            :
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}
\normalsize
where \verb|length| is the length of the \verb|value| in octets (may be
zero).  The list of items in each chunk MUST be terminated by one or more
null octets, the first of which is interpreted as an item type of zero to
denote the end of the list.  No length octet follows the null item type
octet, but additional null octets MUST be included if needed to pad until
the next 32-bit boundary.  Note that this padding is separate from that
indicated by the P bit in the RTCP header.  A chunk with zero items (four
null octets) is valid but useless.

RTCP XR has many sub-packet formats. There doesn't look to be anything
unusual in the formatting beyond standard RTCP packets, however.

\subsection{RTSP}

\subsection{NTP}

The NTP (v4) packet format is:
\begin{itemize}
\item \texttt{Leap Indicator}: 2 bits
\item \texttt{Mode}: 3 bits
\item \texttt{Stratum}: 8 bits
\item \texttt{Poll}: 8 bits
\item \texttt{Precision}: 8 bits
\item \texttt{Root Delay}: 32 bits (NTP short format)
\item \texttt{Root Dispersion}: 32 bits (NTP short format)
\item \texttt{Reference Timestamp}: 64 bits (NTP timestamp format)
\item \texttt{Origin Timestamp}: 64 bits (NTP timestamp format)
\item \texttt{Receive Timestamp}: 64 bits (NTP timestamp format)
\item \texttt{Transmit Timestamp}: 64 bits (NTP timestamp format)
\item \texttt{Extension Fields}: variable length; format below
\item \texttt{Key Identifier}: 32 bits
\item \texttt{Message Digest}: 128 bits
\end{itemize}

Notes:
\begin{itemize}
\item The packet may contain one or more extension fields, with the following format:
\begin{itemize}
\item \texttt{Field Type}: 16 bits
\item \texttt{Length}: 16 bits (length of entire extension field in octets)
\item \texttt{Value}: variable length
\item \texttt{Padding}: variable length as required to pad to 32 bit word
\end{itemize}
\item An interesting component here is the variable number of variable length extension
fields. More specifically, the padding field is included in the length -- this makes
parsing more challenging.
\end{itemize}

\subsection{HTTP/2}

HTTP/2 uses frames, with the following format:
\begin{itemize}
\item \texttt{Length}: 24 bits
\item \texttt{Type}: 8 bits
\item \texttt{Flags}: 8 bits
\item \texttt{Reserved}: 1 bit
\item \texttt{Stream Identifier}: 31 bits
\item \texttt{Payload}: variable length
\end{itemize}

%==============================================================================================

\section{Proposed packet format description language}

\subsection{What can't be described using existing languages?}

What is there in the protocols that we've listed that can't be described using the
languages we've described?

\subsection{What concepts do we need to introduce?}

.. from that, what are the concepts that we need to introduce?

Contexts, interfaces (in the Java sense: state and function signatures, but not definitions)

\subsection{Describing QUIC}

More concretely: what would a description of QUIC look like with a syntax that has the
concepts we've described?

\bibliographystyle{abbrv}
\bibliography{improving-protocol-standards}

\end{document}
