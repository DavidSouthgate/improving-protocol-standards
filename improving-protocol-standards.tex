\documentclass[10pt]{article}
\usepackage[a4paper, total={6.5in, 11in}, includefoot, heightrounded]{geometry}

\title{Literature Survey: Improving Protocol Standards for a more Trustworthy Internet}
\date{\today}

\newcommand{\paper}[3]{\textbf{Paper:} ``\textit{#1}'' -- #2 \cite{#3}\vspace{3mm}}

\begin{document}
\maketitle

This document contains notes on the papers read as part of a literature survey for the
``\textit{Improving Protocol Standards for a more Trustworthy Internet}'' project.

\section{Packet format definition languages}

One of the objectives of the project is to introduce (relatively simple) formalisms into
standards documents, such that tooling can be used to improve the quality of these
documents. One area where documents vary in quality, and that could easily be
improved by our proposed approach, is in the description of packet header formats. The
format used to describe these in standards documents varies, albeit slightly, complicating
their extraction and use by automated tools. Further, given that they are a common feature
in standards documents, any approach that allows for their specification to be simplified
(from the view of the author) is likely to be welcomed.

One approach to improving packet header definitions is through the use of a
domain-specific language (DSL). Such a DSL needs to allow the author to specify not only
the width and type of each field in the packet header, but also the relationships between
them, and any constraints that apply. The language must be accessible: it should reduce
the burden on the author, rather than adding additional complexity to the standards 
process.

The literature survey will cover not only languages specifically designed for packet
header definitions, but data format specification languages more generally.

\subsection{Packet Types}

\paper{Packet Types: Abstract Specification of Network Protocol Messages}{McCann \& Chandra}{mccann2000packet}

McCann and Chandra propose PacketTypes, a packet specification language. Their motivation
is largely focussed on improving the efficiency with which packets can be parsed in
systems applications, though they note that the formal specification of packet formats is
likely to benefit standards specifications. They note that packet formats are fixed by
standards documents, and that implementing parsers is often complicated by the interaction
between different fields, and across the different layers. They use the IP header as an
example: the payload format is constrained by its own packet format, but this is
determined by the protocol field in the IP header. Further, the IP header contains a
variable-length options field; the length of this field is determined by the header length
field. More generally, they show that packet headers encapsulate sufficient complexity
that C's type system is insufficient. As a result, they develop PacketTypes: a
specification language for defining packet formats. They provide an implementation for
their language, and demonstrate its use by implementing a parser for Q.931 messages. 

PacketTypes has one primitive type, a \texttt{bit}. New types can be constructed using the
syntax \texttt{name := type}; for example, \texttt{byte := bit[8]} and
\texttt{bytestring := byte[]}. The square bracket operator (\texttt{[]}) is the same as
the Kleene star: here, a \texttt{bytestring} is comprised of zero or more bytes. Using
an integer inside the square brackets restricts the number of repetitions of the type to
be exactly that number -- so a \texttt{byte} is comprised of exactly 8 \texttt{bit}s.

Structures (e.g., packet headers) can be formed by grouping type definitions together.
From the paper, the IP packet can be defined as:
\begin{verbatim}
nybble := bit[4];
short := bit[16];
long := bit[32];
ipaddress := byte[4];
ipoptions := bytestring;

IP_PDU := {
  nybble       version;
  nybble       ihl;
  byte         tos;
  short        totallength;
  short        identification;
  bit          morefrags;
  bit          dontfrag;
  bit          unused;
  bit          frag_off[13];
  byte         ttl;
  byte         protocol;
  short        cksum;
  ipaddress    src;
  ipaddress    dest;
  ipoptions    options;
  bytestring   payload;
}
\end{verbatim}

While \texttt{IP\_PDU} defines the layout of an IP packet, without any constraints on the
values that each field can contain, by this definition alone, an invalid IP packet could
be constructed. PacketTypes allows a \texttt{where} clause to follow a type definition.
For example:

\begin{verbatim}
IP_PDU := {
  ...
} where {
  version#value = 0x04;
  options#numbytes = ihl#value * 4 - 20;
  payload#numbytes = totallength#value - ihl#value * 4;
}
\end{verbatim}

In this example, the \texttt{where} clause specifies that the IP version is 4, and defines
the size of the \texttt{options} and \texttt{payload} fields based on the \texttt{ihl}
and \texttt{totallength} fields. Note the introduction of new syntax here:
\texttt{field\#attribute} is used to refer to a particular attribute of a field. A number
of attributes are defined, including \texttt{value} (network-order concatenation of all
bits in the field), \texttt{numbits} (count of the number of bits in the field),
\texttt{numbytes} (count of the number of bytes in the field), \texttt{numelems} (count
of the number of elements in an array field), and \texttt{alt} (booleans indicating the
alternative chosen). In the absence of a constraints, the \texttt{[]} operator is greedy;
it is assumed that any data that could belong to that field does. It might be constrained
explicitly by the \texttt{where} clause, or implicitly, based on the length of the
structure that holds it.

A refinement operator, \texttt{:>} is defined. This is used to further constrain a type
that has already been specified. From the paper, an Ethernet frame could be specified as:

\begin{verbatim}
macaddr := bit[48];

Ethernet_PDU := {
  macaddr      dest;
  macaddr      src;
  short        type;
  bytestring   payload;
}
\end{verbatim}

Using a refinement, an IP packet within an Ethernet frame could be defined as:

\begin{verbatim}
IPinEthernet :> Ethernet_PDU where {
  type#value = 0x800;
  overlay payload with IP_PDU;
}
\end{verbatim}

This specifies the type as \texttt{0x800}, and overlays the \texttt{IP\_PDU} definition
above on top of the Ethernet payload. The \texttt{overlay .. with} syntax embeds one type
within the other, reflecting protocol encapsulation. Here, the constraints of the
\texttt{IP\_PDU} definition are applied to the \texttt{payload} field of
\texttt{Ethernet\_PDU}; for a packet to be a valid \texttt{IPinEthernet} packet, its
Ethernet header must have \texttt{type} equal to \texttt{0x800}, and a payload that is a
valid \texttt{IP\_PDU} packet.

PacketTypes includes dot notation syntax to allow the fields in the overlaid structure to
be accessed:

\begin{verbatim}
My_IPinEthernet :> IPinEthernet where {
  payload.srcaddr#value = 192.168.0.1;
}
\end{verbatim}

In this example, the \texttt{payload} is the \texttt{Ethernet\_PDU} payload; the dot
notation allows for the \texttt{srcaddr} of the overlaid \texttt{IP\_PDU} definition to be
accessed, and here, have its value specified.

Alternative types can be specified using the alternation operator, \texttt{|=}. This
combines types disjunctively -- a bitstring matches the defined type if it matches one of
the alternatives. As an example, the paper gives a more precision definition of the
\texttt{ipoptions} type:

\begin{verbatim}
ipoptions := {
  NonEndOption     neo[];
  EndOption        eo;
  bytestring       padding;
} where {
  eo#numelems <= 1;
}
\end{verbatim}

By this definition, IP options are comprised of a zero or more \texttt{NonEndOption}s,
followed by an optional (zero or one) \texttt{EndOption}, and padding.
\texttt{NonEndOption}s make use of the alternation operator:

\begin{verbatim}
NonEndOption |= {
  NoOperation     nop;
  Security        sec;
  LSRR            lsrr;
  SSRR            ssrr;
  RR              rr;
  StreamID        sid;
  Timestamp       tstamp;
}
\end{verbatim}

The \texttt{|=} means that a bitstring is a \texttt{NonEndOption} if and only if it is one
of the alternative types given. The \texttt{\#alt} attribute can be used in the
\texttt{where} clause to determine which alternative was matched. Boolean expressions can
be constructed; for example \texttt{neo[0]\#alt @ nop} is true if the first
\texttt{NonEndOption} in the IP options field is a \texttt{NoOperation}. Note the use of
the \texttt{@} operator here.

Constraints in the \texttt{where} clause can be expressed using relational operators and
boolean combinators:
\begin{verbatim}
          = > < >= <= != || && + * / -
\end{verbatim}

PacketTypes limits, for computability, the possible set of constraints. Constraints that
specify the size of variable-sized fields must only reference attributes that have already
been specified. The authors allow particular implementations to further limit
constraints.

\subsection{Meta Packet Language}
\paper{Melange: Creating a ``Functional'' Internet}{Madhavapeddy et al.}{madhavapeddy2007melange}

The motivation for Melange is centres on the widespread use of type-unsafe languages (like
C and C++) in network system implementations, exposing such systems to security and
reliability issues. Melange combines two techniques to eliminate the perceived performance
impact of type-safe languages, allowing for their use in implementing Internet protocols:
a strong, static type system, and generative meta-programming. Of interest here is their
domain-specific language, Meta Packet Language (MPL).

The authors provide the Extended BNF grammar for MPL:

\begin{verbatim}
main -> (packet-decl)+ EOF
packet-decl -> packet identifier[(packet-args)] packet-body
packet-args -> {int | bool} identifier [, packet-args]
packet-body -> {(statement)+}
statement -> identifier : identifier [var-size] (var-attr)*;
           | classify (identifier) {(classify-match)+};
           | identifier : array(expr) {(statement)+};
           | ();
classify-match -> '|' expr : expr[when (expr)] -> (statement)+
var-attr -> variant {('|' expr {->|=>} cap-identifier)+}
          | {min|max|align|value|const|default} (expr)
var-size -> [expr]
expr -> integer | string | identifier | (expr)
      | expr {+|-|*|/|and|or} expr
      | {-|+|not} expr
      | true | false
      | expr {>|>=|<|<=|=|..} expr
      | {sizeof|array_length|offset} (expr-arg)
      | remaining()
\end{verbatim}

A simple specification in MPL consists of an ordered list of named \emph{typed} fields.
Types can be: (i) wire types (network representation of the field); (ii) MPL types (used
within the specification -- strings in the grammar above); or (iii) language types (used
in target language -- i.e., the language that the MPL is compiled to). Wire types are
mapped to MPL types, allowing these types to be used as part of the specification.
Additionally, every wire type has a corresponding language type. 

The grammar includes the \texttt{classify} keyword, to allow for parsing decisions to
depend on the contents of another field (so long as that field has already been defined).
Fields have attributes; these can be constraints that define the maximum or minimum value,
a default value, or a constant value, among others. 

As an example, the authors provide an MPL specification of IPv4:

\begin{verbatim}
packet ipv4 {
  version: bit[4] const(4);
  ihl: bit[4] min(5) value(offset(options) / 4);
  tos_precedence: bit[3] variant {
    |0 => Routine
    |1 -> Priority
    |2 -> Immediate
    |3 -> Flash
    |4 -> Flash_override
    |5 -> ECP
    |6 -> Inet_control
    |7 -> Net.control
  };
  delay: bit[1] default(false);
  throughput: bit[1] default(false);
  reliability: bit[1] default(false);
  reserved: bit[2] const(0);
  length: uint16 value(offset(data));
  id: uint16;
  reserved: bit[1] const(0);
  dont_fragment: bit[1] default(0);
  can_fragment: bit[1] default(0);
  frag_off: bit[13] default(0);
  ttl: byte;
  protocol: byte variant {
   |1 -> ICMP
   |2 -> IGMP
   |6 -> TCP
   |17 -> UDP
  };
  checksum: uint16 default(0);
  src: uint32;
  dest: uint32;
  options: byte[(ihl * 4) - offset(dest)] align(32);
  header_end: label;
  data: byte[length-(ihl*4)];
}
\end{verbatim}

\subsection{PADS}
\paper{PADS: A Domain-Specific Language for Processing Ad Hoc Data}{Fisher and Gruber}{fisher2005pads}

\subsection{DataScript}
\paper{DataScript: A Specification and Scripting Language for Binary Data}{Back}{back2002datascript}

Back describes DataScript, a language for the specification and manipulation of binary
data formats, using types. It consists of two components: a constraint-based specification
language (that uses DataScript types), and a language binding that provides a simple
scripting interface. The motivation for DataScript is that natural language prose is not
well suited to describing the design of binary data formats: not only is it inefficient,
but it can introduce ambiguities that translate into bugs in implementations. 

A DataScript type can be either: (i) a primitive type; (ii) a set type (an enumerated
or bitmask type); (iii) a linear array (of another type); or (iv) a composite (record or
variant-record) type.

Primitive types form the basis for more complicated types. These types include bit fields,
bytes, and variable length integers. Primitive types are interpreted as signed or unsigned
integers, with the size and signedness specified in the keyword (e.g., uint32, int16). For 
multi-byte integers, endianness is specified using an optional attribute prefix:
\texttt{little} or \texttt{big}. Where this isn't specified, the default is big endian 
(i.e., network byte order).

Two set types are supported: enumerated types (\texttt{enum}) and bitmask types
(\texttt{bitmask}). A set type constrains an underlying primitive type, specifying the
signedness and endianness, used to store and interpret its values. For example, it can be
used to specify the valid values of a bitfield.

Composite types are specified using a C-like language, and this follows from the
interpretation of these types: they are similar to C structs and unions. Unions in
DataScript are discriminated/tagged, taking the first matching constraint in the union --
the order in the specification is important. The constraints don't need to be disjoint,
allowing for default choices. Composite types can be nested, with scoping rules that
provide a namespace for each type.

DataScript arrays are linear, with integer indices, and specified lower and upper
bounds (\texttt{[lower.. upper]}; lower is a valid indice, upper is not); lower, if
omitted defaults to 0. Expressions specifying bounds must be able to be evaluated at the
time that the array is read (i.e., be based on a previously defined field). 

Fields can have constraints, specified as a boolean predicate. Constraints are used in
three ways: (i) to discriminate union types; (ii) express consistency requirements in
record types; and (ii) limit the length of array types, where the length is not known;
arrays can grow until their constraints are violated. Predicates are boolean expressions,
with DataScript adopting the operators, associativity, and precedence rules from Java and
C. 

\subsection{P4}
\paper{P4: Programming protocol-independent packet processors}{Bosshart et al.}{bosshart2014p4}

\bibliographystyle{abbrv}
\bibliography{improving-protocol-standards}

\end{document}