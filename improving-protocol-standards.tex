\documentclass[10pt]{article}
\usepackage[a4paper, total={6.5in, 11in}, includefoot, heightrounded]{geometry}
\usepackage{adjustbox}
\usepackage{array}
\usepackage{color}

\title{Literature Survey: Improving Protocol Standards for a more Trustworthy Internet}
\date{\today}

\newcommand{\todo}[1]{\textbf{\textcolor{red}{To do -- #1}}}
\newcommand{\paper}[3]{\vspace{4mm}\noindent\textbf{Paper:} ``\textit{#1}'' -- #2 \cite{#3}\vspace{3mm}}

\newcolumntype{R}[2]{%
    >{\adjustbox{angle=#1,lap=\width-(#2)}\bgroup}%
    l%
    <{\egroup}%
}
\newcommand*\rot{\multicolumn{1}{R{45}{1em}}}

\begin{document}
\maketitle

This document contains notes on the papers read as part of a literature survey for the
``\textit{Improving Protocol Standards for a more Trustworthy Internet}'' project.

\section{Packet format definition languages}

One of the objectives of the project is to introduce (relatively simple) formalisms into
standards documents, such that tooling can be used to improve the quality of these
documents. One area where documents vary in quality, and that could easily be
improved by our proposed approach, is in the description of packet header formats. The
format used to describe these in standards documents varies, albeit slightly, complicating
their extraction and use by automated tools. Further, given that they are a common feature
in standards documents, any approach that allows for their specification to be simplified
(from the view of the author) is likely to be welcomed.

One approach to improving packet header definitions is through the use of a
domain-specific language (DSL). Such a DSL needs to allow the author to specify not only
the width and type of each field in the packet header, but also the relationships between
them, and any constraints that apply. The language must be accessible: it should reduce
the burden on the author, rather than adding additional complexity to the standards 
process.

The literature survey will cover not only languages specifically designed for packet
header definitions, but data format specification languages more generally. In addition,
architectural papers (i.e., those that don't define a language, but provide guidance) are
also in scope.

\subsection{Languages}

\paper{Packet Types: Abstract Specification of Network Protocol Messages}{McCann \& Chandra}{mccann2000packet}

McCann and Chandra propose PacketTypes, a packet specification language. Their motivation
is largely focussed on improving the efficiency with which packets can be parsed in
systems applications, though they note that the formal specification of packet formats is
likely to benefit standards specifications. They note that packet formats are fixed by
standards documents, and that implementing parsers is often complicated by the interaction
between different fields, and across the different layers. They use the IP header as an
example: the payload format is constrained by its own packet format, but this is
determined by the protocol field in the IP header. Further, the IP header contains a
variable-length options field; the length of this field is determined by the header length
field. More generally, they show that packet headers encapsulate sufficient complexity
that C's type system is insufficient. As a result, they develop PacketTypes: a
specification language for defining packet formats. They provide an implementation for
their language, and demonstrate its use by implementing a parser for Q.931 messages. 

PacketTypes has one primitive type, a \texttt{bit}. New types can be constructed using the
syntax \texttt{name := type}; for example, \texttt{byte := bit[8]} and
\texttt{bytestring := byte[]}. The square bracket operator (\texttt{[]}) is the same as
the Kleene star: here, a \texttt{bytestring} is comprised of zero or more bytes. Using
an integer inside the square brackets restricts the number of repetitions of the type to
be exactly that number -- so a \texttt{byte} is comprised of exactly 8 \texttt{bit}s.

Structures (e.g., packet headers) can be formed by grouping type definitions together.
From the paper, the IP packet can be defined as:
\begin{verbatim}
nybble := bit[4];
short := bit[16];
long := bit[32];
ipaddress := byte[4];
ipoptions := bytestring;

IP_PDU := {
  nybble       version;
  nybble       ihl;
  byte         tos;
  short        totallength;
  short        identification;
  bit          morefrags;
  bit          dontfrag;
  bit          unused;
  bit          frag_off[13];
  byte         ttl;
  byte         protocol;
  short        cksum;
  ipaddress    src;
  ipaddress    dest;
  ipoptions    options;
  bytestring   payload;
}
\end{verbatim}

While \texttt{IP\_PDU} defines the layout of an IP packet, without any constraints on the
values that each field can contain, by this definition alone, an invalid IP packet could
be constructed. PacketTypes allows a \texttt{where} clause to follow a type definition.
For example:

\begin{verbatim}
IP_PDU := {
  ...
} where {
  version#value = 0x04;
  options#numbytes = ihl#value * 4 - 20;
  payload#numbytes = totallength#value - ihl#value * 4;
}
\end{verbatim}

In this example, the \texttt{where} clause specifies that the IP version is 4, and defines
the size of the \texttt{options} and \texttt{payload} fields based on the \texttt{ihl}
and \texttt{totallength} fields. Note the introduction of new syntax here:
\texttt{field\#attribute} is used to refer to a particular attribute of a field. A number
of attributes are defined, including \texttt{value} (network-order concatenation of all
bits in the field), \texttt{numbits} (count of the number of bits in the field),
\texttt{numbytes} (count of the number of bytes in the field), \texttt{numelems} (count
of the number of elements in an array field), and \texttt{alt} (booleans indicating the
alternative chosen). In the absence of a constraints, the \texttt{[]} operator is greedy;
it is assumed that any data that could belong to that field does. It might be constrained
explicitly by the \texttt{where} clause, or implicitly, based on the length of the
structure that holds it.

A refinement operator, \texttt{:>} is defined. This is used to further constrain a type
that has already been specified. From the paper, an Ethernet frame could be specified as:

\begin{verbatim}
macaddr := bit[48];

Ethernet_PDU := {
  macaddr      dest;
  macaddr      src;
  short        type;
  bytestring   payload;
}
\end{verbatim}

Using a refinement, an IP packet within an Ethernet frame could be defined as:

\begin{verbatim}
IPinEthernet :> Ethernet_PDU where {
  type#value = 0x800;
  overlay payload with IP_PDU;
}
\end{verbatim}

This specifies the type as \texttt{0x800}, and overlays the \texttt{IP\_PDU} definition
above on top of the Ethernet payload. The \texttt{overlay .. with} syntax embeds one type
within the other, reflecting protocol encapsulation. Here, the constraints of the
\texttt{IP\_PDU} definition are applied to the \texttt{payload} field of
\texttt{Ethernet\_PDU}; for a packet to be a valid \texttt{IPinEthernet} packet, its
Ethernet header must have \texttt{type} equal to \texttt{0x800}, and a payload that is a
valid \texttt{IP\_PDU} packet.

PacketTypes includes dot notation syntax to allow the fields in the overlaid structure to
be accessed:

\begin{verbatim}
My_IPinEthernet :> IPinEthernet where {
  payload.srcaddr#value = 192.168.0.1;
}
\end{verbatim}

In this example, the \texttt{payload} is the \texttt{Ethernet\_PDU} payload; the dot
notation allows for the \texttt{srcaddr} of the overlaid \texttt{IP\_PDU} definition to be
accessed, and here, have its value specified.

Alternative types can be specified using the alternation operator, \texttt{|=}. This
combines types disjunctively -- a bitstring matches the defined type if it matches one of
the alternatives. As an example, the paper gives a more precision definition of the
\texttt{ipoptions} type:

\begin{verbatim}
ipoptions := {
  NonEndOption     neo[];
  EndOption        eo;
  bytestring       padding;
} where {
  eo#numelems <= 1;
}
\end{verbatim}

By this definition, IP options are comprised of a zero or more \texttt{NonEndOption}s,
followed by an optional (zero or one) \texttt{EndOption}, and padding.
\texttt{NonEndOption}s make use of the alternation operator:

\begin{verbatim}
NonEndOption |= {
  NoOperation     nop;
  Security        sec;
  LSRR            lsrr;
  SSRR            ssrr;
  RR              rr;
  StreamID        sid;
  Timestamp       tstamp;
}
\end{verbatim}

The \texttt{|=} means that a bitstring is a \texttt{NonEndOption} if and only if it is one
of the alternative types given. The \texttt{\#alt} attribute can be used in the
\texttt{where} clause to determine which alternative was matched. Boolean expressions can
be constructed; for example \texttt{neo[0]\#alt @ nop} is true if the first
\texttt{NonEndOption} in the IP options field is a \texttt{NoOperation}. Note the use of
the \texttt{@} operator here.

Constraints in the \texttt{where} clause can be expressed using relational operators and
boolean combinators:
\begin{verbatim}
          = > < >= <= != || && + * / -
\end{verbatim}

PacketTypes limits, for computability, the possible set of constraints. Constraints that
specify the size of variable-sized fields must only reference attributes that have already
been specified. The authors allow particular implementations to further limit
constraints.

\paper{Melange: Creating a ``Functional'' Internet}{Madhavapeddy et al.}{madhavapeddy2007melange}

The motivation for Melange is centres on the widespread use of type-unsafe languages (like
C and C++) in network system implementations, exposing such systems to security and
reliability issues. Melange combines two techniques to eliminate the perceived performance
impact of type-safe languages, allowing for their use in implementing Internet protocols:
a strong, static type system, and generative meta-programming. Of interest here is their
domain-specific language, Meta Packet Language (MPL).

The authors provide the Extended BNF grammar for MPL:

\begin{verbatim}
main -> (packet-decl)+ EOF
packet-decl -> packet identifier[(packet-args)] packet-body
packet-args -> {int | bool} identifier [, packet-args]
packet-body -> {(statement)+}
statement -> identifier : identifier [var-size] (var-attr)*;
           | classify (identifier) {(classify-match)+};
           | identifier : array(expr) {(statement)+};
           | ();
classify-match -> '|' expr : expr[when (expr)] -> (statement)+
var-attr -> variant {('|' expr {->|=>} cap-identifier)+}
          | {min|max|align|value|const|default} (expr)
var-size -> [expr]
expr -> integer | string | identifier | (expr)
      | expr {+|-|*|/|and|or} expr
      | {-|+|not} expr
      | true | false
      | expr {>|>=|<|<=|=|..} expr
      | {sizeof|array_length|offset} (expr-arg)
      | remaining()
\end{verbatim}

A simple specification in MPL consists of an ordered list of named \emph{typed} fields.
Types can be: (i) wire types (network representation of the field); (ii) MPL types (used
within the specification -- strings in the grammar above); or (iii) language types (used
in target language -- i.e., the language that the MPL is compiled to). Wire types are
mapped to MPL types, allowing these types to be used as part of the specification.
Additionally, every wire type has a corresponding language type. 

The grammar includes the \texttt{classify} keyword, to allow for parsing decisions to
depend on the contents of another field (so long as that field has already been defined).
Fields have attributes; these can be constraints that define the maximum or minimum value,
a default value, or a constant value, among others. 

As an example, the authors provide an MPL specification of IPv4:

\begin{verbatim}
packet ipv4 {
  version: bit[4] const(4);
  ihl: bit[4] min(5) value(offset(options) / 4);
  tos_precedence: bit[3] variant {
    |0 => Routine
    |1 -> Priority
    |2 -> Immediate
    |3 -> Flash
    |4 -> Flash_override
    |5 -> ECP
    |6 -> Inet_control
    |7 -> Net.control
  };
  delay: bit[1] default(false);
  throughput: bit[1] default(false);
  reliability: bit[1] default(false);
  reserved: bit[2] const(0);
  length: uint16 value(offset(data));
  id: uint16;
  reserved: bit[1] const(0);
  dont_fragment: bit[1] default(0);
  can_fragment: bit[1] default(0);
  frag_off: bit[13] default(0);
  ttl: byte;
  protocol: byte variant {
   |1 -> ICMP
   |2 -> IGMP
   |6 -> TCP
   |17 -> UDP
  };
  checksum: uint16 default(0);
  src: uint32;
  dest: uint32;
  options: byte[(ihl * 4) - offset(dest)] align(32);
  header_end: label;
  data: byte[length-(ihl*4)];
}
\end{verbatim}

\paper{PADS: A Domain-Specific Language for Processing Ad Hoc Data}{Fisher and Gruber}{fisher2005pads}

Processing Ad hoc Data Sources (PADS) is a declarative data description language for
describing the layout and semantic properties of \emph{ad hoc} data. Ad hoc, in this
context, refers to data formats that are stored in (previously) ill-defined, non-standard
formats. This in contrast to data stored in database systems, or described using a
structured language (e.g., XML). The authors cite examples of such data: call logs, web
server access logs, etc. While much of the motivation for PADS does not apply here (i.e.,
we are not describing ad hoc data), of interest is the motivation that runs through most
of the papers in this document: parsers are tedious to write, and the process is
error-prone. A formal or structured description of the data is desirable to improve this
situation.

The PADS description language is typed-based, with atomic base types for 32-bit integers
(\texttt{Pint32}), strings (\texttt{Pstring}), and IP address (\texttt{Pip}), among
others. These types are augmented with information about how the data is coded (e.g., in
ASCII or binary). PADS interprets the types as ASCII by default, but this can be specified
by using the appropriate base type: for example, \texttt{Pa\_int32} is an \emph{ASCII}
32-bit integer, \texttt{Pb\_int32} is a \emph{binary} 32-bit integer. Users can specify
their own base types.

PADS includes structured types, akin to C's types: \texttt{Pstruct} (structures),
\texttt{Punion} (alternatives), and \texttt{Parray} (sequences), \texttt{Penum} (fixed set
of literals), \texttt{Popts} (optional data). Each of these can have a predicate
associated with it, to indicate whether a parsed value is a legal value for the type. For
example, a predicate might specify that two fields of a \texttt{Pstruct} are related, or
that a sequence is in increasing order. These predicates are specified using C-like
syntax. Further constraints can be added to existing types using \texttt{Ptypedef}. PADS
types may be parameterised by values. For example, \texttt{Pstring(:' ':)} defines a
string terminated by a space. 

\paper{DataScript: A Specification and Scripting Language for Binary Data}{Back}{back2002datascript}

Back describes DataScript, a language for the specification and manipulation of binary
data formats, using types. It consists of two components: a constraint-based specification
language (that uses DataScript types), and a language binding that provides a simple
scripting interface. The motivation for DataScript is that natural language prose is not
well suited to describing the design of binary data formats: not only is it inefficient,
but it can introduce ambiguities that translate into bugs in implementations. 

A DataScript type can be either: (i) a primitive type; (ii) a set type (an enumerated
or bitmask type); (iii) a linear array (of another type); or (iv) a composite (record or
variant-record) type.

Primitive types form the basis for more complicated types. These types include bit fields,
bytes, and variable length integers. Primitive types are interpreted as signed or unsigned
integers, with the size and signedness specified in the keyword (e.g., uint32, int16). For 
multi-byte integers, endianness is specified using an optional attribute prefix:
\texttt{little} or \texttt{big}. Where this isn't specified, the default is big endian 
(i.e., network byte order).

Two set types are supported: enumerated types (\texttt{enum}) and bitmask types
(\texttt{bitmask}). A set type constrains an underlying primitive type, specifying the
signedness and endianness, used to store and interpret its values. For example, it can be
used to specify the valid values of a bitfield.

Composite types are specified using a C-like language, and this follows from the
interpretation of these types: they are similar to C structs and unions. Unions in
DataScript are discriminated/tagged, taking the first matching constraint in the union --
the order in the specification is important. The constraints don't need to be disjoint,
allowing for default choices. Composite types can be nested, with scoping rules that
provide a namespace for each type.

DataScript arrays are linear, with integer indices, and specified lower and upper
bounds (\texttt{[lower.. upper]}; lower is a valid indice, upper is not); lower, if
omitted defaults to 0. Expressions specifying bounds must be able to be evaluated at the
time that the array is read (i.e., be based on a previously defined field). 

Fields can have constraints, specified as a boolean predicate. Constraints are used in
three ways: (i) to discriminate union types; (ii) express consistency requirements in
record types; and (ii) limit the length of array types, where the length is not known;
arrays can grow until their constraints are violated. Predicates are boolean expressions,
with DataScript adopting the operators, associativity, and precedence rules from Java and
C. 

\paper{P4: Programming protocol-independent packet processors}{Bosshart et al.}{bosshart2014p4}

P4 is a high-level language, designed for programming packet processors (e.g., switches).
The goals of P4 are to allow for easy reconfigurability of switches once deployed,
the development of an abstraction to allow switches to be protocol agnostic, and a further
abstraction to allow the programming of switches to be independent of the underlying
hardware. While this goals are very different to those of this project, they lead to the
development of a programming language that has many desirable features.

A P4 program is comprised of five components:
\begin{itemize}
\item \textbf{Headers} The sequence and structure of packets
\item \textbf{Parsers} Definition of how headers should be identified and validated
\item \textbf{Tables} Packet matching tables for packet processing
\item \textbf{Actions} Triggered by matching a table entry
\item \textbf{Control Programs} Defines ordering and flow between matching (and action) entries
\end{itemize}

Of these, header definitions are of interest. These are specified by declaring an ordered
list of field names, together with their bit widths. For example, the Ethernet header is
specified as:

\begin{verbatim}
  header ethernet {
    fields {
      dst_addr : 48; // width in bits
      src_addr : 48;
      ethertype : 16;
    }
  }
\end{verbatim}

[Note: the P4 paper doesn't focus on the header specification language; the P4 manual is
a better resource. The language has also changed considerably since this paper]

\paper{Abstract Syntax Notation One (ASN.1): Specification of basic notation}{ITU-T (Information technology)}{x680}

ASN.1 is a language for defining the structure of data. It includes a number of simple
data types, and notation for referencing and specifying values for these. Importantly,
this notation does not constrain the encoding format for the data being specified. This
is handled by supplementary encoding rules: the ``transfer syntax'' -- e.g., Basic
Encoding Rules (BER), or Packed Encoding Rules (PER). The focus here is on the abstract
notation, and the semantics it supports.

ASN.1 supports the general technique of defining a small core of simple types, and
allowing these to be combined in various ways to define new types. These new types can
be defined, for example, by composing an ordered sequence of the existing types, or using
other structures or relationships. To allow for the unambiguous encoding of these types,
they are assigned a tag: these are helpers for parsers of the language, rather than for
human readers.

An instance of the ASN.1 notation (defining types, values, sets, etc) is a
module. Modules definitions being with this syntax:

\begin{verbatim}
  ModuleIdentifier DEFINITIONS ::= BEGIN
\end{verbatim}

Modules contain type definitions:

\begin{verbatim}
  ModuleIdentifier DEFINITIONS ::= BEGIN
      TypeIdentifier ::= SEQUENCE {
          label     INTEGER,
          label2    BOOLEAN
      }
  END
\end{verbatim}

ASN.1 allows for values to be constrained:

\begin{verbatim}
  ModuleIdentifier DEFINITIONS ::= BEGIN
      TypeIdentifier ::= SEQUENCE {
          label     INTEGER(0..15),
          label2    BOOLEAN
      }
  END  
\end{verbatim}

Additionally, definitions can be reused and extended:

\begin{verbatim}
  ModuleIdentifier DEFINITIONS ::= BEGIN
      TypeIdentifier ::= SEQUENCE {
          label     INTEGER,
          label2    BOOLEAN
      }
    
      TypeIdentiferExtension ::= SEQUENCE {
          label3    SEQUENCE OF TypeIdentifier,
          ...
      }
  END
\end{verbatim}

The ``..'' is part of the language: it says that the TypeIdentifierExtension specification
might contain additional fields in later versions.

\paper{A language-based approach to protocol construction}{Basu et al.}{basu1997language}

Basu et al. describe Promela++, an extension to the Promela protocol validation language.
Promela++ adds constructs for specifying layered protocols and for composing these
protocols into a stack. In addition, it provides support for the encapsulation of
protocol state, and message headers. Again, the focus here is on the language itself, and
the semantics it supports, rather than on the tooling that is described alongside it.

Promela++ is syntactically similar to C, but with a number of modifications and
constraints. Importantly, Promela++ separates the lower-level network access and data
handling components from the protocol-layer control structures. This has a number of
advantages, allowing the low-level components to be hidden from the protocol-level
validator.

In Promela++, a protocol layer is comprised of user-defined types that encapsulate the
state of the protocol layer, and the message header used by the protocol layer. These
are flagged using the \texttt{state} and \texttt{message} keywords respectively. Of 
interest here is the message header defintion language.

Message headers are expressed as:

\begin{verbatim}
  message UAM_msg {
    UAM_short        am,
    ...
  };
\end{verbatim}

\paper{CSN. 1 Specification, Version 2.0}{Mouly}{mouly1998csn}

The Concrete Syntax Notation, CSN.1, is a language that was introduced by 3GPP, to aid in
the description of the \emph{encoded} format of layer 3 GSM messages. Previously, these
messages were described with various ad hoc methods, including textual descriptions of the
meaning of each bit. The goals of CSN.1, then, are to unify the way in which these
messages are described, using a formal language, and in so doing, encourage the
development of tooling that could generate encoding/decoding programs.

CSN.1 operates over a logical bit stream, of arbitrary length. A CSN.1 definition
describes the transmission syntax, defining which sequences of bits are valid. In
addition, components of the bit stream are labelled. However, CSN.1 does not allow for any
relationships between these different components to be modelled. The meaning of each value
is not defined; no attempt is made to constrain a given message to carry a set of values
that all make sense together.

As an example:

\begin{verbatim} < TEST > ::= 00001111; \end{verbatim}

Here, \texttt{TEST} has a fixed value (15).

\begin{verbatim} < TEST_OR > ::= 0000 {1111 | 0000}; \end{verbatim}

In this example, \texttt{TEST\_OR} can take on two possible (8-bit) values: 0 or 15.
However, there is no notation to define when \texttt{TEST\_OR} should take on either of
those values: that is entirely application dependent, and cannot be modelled here.

\subsection{Packet parser design principles}
\paper{Design principles for packet parsers}{Gibb et al.}{gibb2013design}

In this paper, the authors discuss the design tradeoffs present in packet parsers, and
identify the design principles that exist. Additionally, they describe a parser generator.
As part of this parser generator, a language to describe packet formats is defined.
As an example, the IPv4 header is described as:

\begin{verbatim}
  ipv4 {
    fields {
      version        :  4,
      ihl            :  4,
      diffserv       :  8 : extract,
      totalLen       : 16,
      identification : 16,
      flags          :  3 : extract,
      fragOffset     : 13,
      ttl            :  8 : extract,
      protocol       :  8 : extract,
      hdrChecksum    : 16,
      srcAddr        : 32 : extract,
      dstAddr        : 32 : extract,
      options        : *,
    }
    next_header = map(fragOffset, protocol) {
       1 : icmp,
       6 : tcp,
      17 : udp,
    }
    length = ihl * 4 * 8
    max_length = 256
  }
\end{verbatim}

This description includes the name and size of each field, a label for fields that should
be extracted, a mapping between field values, and for variable-length headers, a
definition of length derived from field values.

\todo{Expand}

\paper{Writing parsers like it is 2017}{Chifflier and Couprie}{chifflier2017writing}

In this paper, the authors present a Rust-based combinator approach to parser design. This
is motivated by the prevalence of memory corruption bugs in parsers implemented in
low-level languages. Many of the issues raised by the authors result from the use of
unsafe languages, such as C, for parser implementation, and they recommend changing to a 
safe language, such as Rust, to solve many of these.

\todo{Expand}

\subsection{Network protocol DSLs \& motivation}

\paper{Domain specific languages (DSLs) for network protocols}{Bhatti et al.}{bhatti2009domain}

\todo{Write up notes}

\paper{The Bugs We Have to Kill}{Bratus et al.}{bratus2015bugs}

\todo{Read and write up}

\subsection{Summary}

\begin{tabular}{ l | c | r }
  Language/Feature & \rot{Field types} & \rot{Field relationships} \\   \hline			
  PacketTypes      & $\bullet$     & $\bullet$  \\
  DataScript       & $\bullet$     & $\bullet$  \\
  \hline  
\end{tabular}

\todo{Add all languages}
\todo{Add list of features}

\bibliographystyle{abbrv}
\bibliography{improving-protocol-standards}

\end{document}