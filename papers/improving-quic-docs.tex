%==================================================================================================
% LaTeX paper template - use as a starting point for structuring a paper.
%
% Written by Colin Perkins (https://csperkins.org/)
% 2002-2017
%
% To the extent possible under law, the author(s) have dedicated all copyright and
% related and neighbouring rights to this software to the public domain worldwide.
% This software is distributed without any warranty.
%
% You should have received a copy of the CC0 Public Domain Dedication along with
% this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
%
%==================================================================================================
% General advice on technical writing:
%  - George Gopen and Judith Swan, "The Science of Scientific Writing",
%    American Scientist, Nov/Dec 1990. 
%    http://www.americanscientist.org/issues/num2/the-science-of-scientific-writing/1
%  - Stephen Pinker, "The Sense of Style: The Thinking Person's Guide to
%    Writing in the 21st Century", Penguin, Sept 2014. ISBN 0525427929.
%
% The paper writing advice in the comments is derived from talks and articles
% by Simon Peyton-Jones, Jim Kurose, Henning Schulzrinne, and Jim Bednar: 
%  - http://research.microsoft.com/~simonpj/papers/giving-a-talk/giving-a-talk.htm
%  - http://research.microsoft.com/~simonpj/papers/giving-a-talk/writing-a-paper-slides.pdf
%  - http://gaia.cs.umass.edu/kurose/talks/top_10_tips_for_writing_a_paper.ppt
%  - http://www-net.cs.umass.edu/kurose/writing/intro-style.html
%  - http://www.cs.columbia.edu/~hgs/etc/writing-style.html
%  - http://homepages.inf.ed.ac.uk/jbednar/writingtips.html
%  - http://www.gabbay.org.uk/blog/paper-writing.html
%  - http://homes.cs.washington.edu/~mernst/advice/write-technical-paper.html
%  - https://doi.org/10.1371/journal.pcbi.1005619
%
%==================================================================================================
\documentclass[10pt,sigconf]{acmart}
% The \documentclass line will need to be updated to use the appropriate
% class for your chosen venue. 
% 
% For IEEE style use:
%   \documentclass[conference]{IEEEtran}
%
% For the ACM SIGCOMM style use:
%   \documentclass{sig-alternate}
% or
%   \documentclass{sig-alternate-10pt}
% 
% The IEEE and ACM templates are included in the lib/tex/inputs directory.
% The bin/latex-build.sh script is set to search this directory for class
% files before the versions included with your LaTeX distribution. 
% 
% The ACM templates (sig-alternate.cls and sig-alternate-10pt.cls) included
% have been edited to remove \usepackage{epsfig}, as the epsfig package has
% long been deprecated in favour of graphicx. They also include a number of
% other minor bug fixes. These modifications don't change the output format.

% The following packages are recommended, and should be available in most
% standard LaTeX installations (or from https://www.ctan.org/). Note that 
% the order in which these packages are loaded is significant.
\usepackage[l2tabu,orthodox]{nag}  % Warn about use of obsolete LaTeX packages/constructs
\usepackage[utf8]{inputenc}       % This file is formatted in UTF-8
\usepackage[british]{babel}        % Use British hyphenation patterns
\usepackage{ifpdf}                 % Support conditional use of PDF-specific features
% Use the AMS mathematics library for improved mathematics support (see
% http://ctan.org/pkg/amsmath). When this package is loaded, use:
%   \begin{align}
%     ...
%   \end{align} 
% instead of:
%   \begin{eqnarray}
%     ...
%   \end{eqnarray}.  
% (see https://tug.org/pracjourn/2006-4/madsen/madsen.pdf)
\usepackage{amsmath}
\usepackage[all]{onlyamsmath}
% Use Times, Helvetica, and Courier fonts, rather than Computer Modern
\usepackage{upquote}   % Fix quotes in verbatim environments
\usepackage{graphicx}  % Enhanced graphics support
\usepackage{url}       % Add support for typesetting URLs using \url{...}:
% Add support for subfigures, as follows:
%   \begin{figure}
%     \centering
%     \subfloat[caption for 1st subfloat]{
%       \includegraphics{...}
%       \label{...}
%     }
%     \\
%     \subfloat[caption for 2nd subfloat]{
%       \includegraphics{...}
%       \label{...}
%     }
%     \caption{caption for entire figure}
%     \label{...}
%   \end{figure*}
% The subfig package obsoletes the older subfigure package, and is itself
% deprecated in favour of the subcaption package. However, as of April 2015
% subcaption doesn't work with ACM or IEEE style files (this is also the
% reason for the [caption=false] option).
\usepackage[caption=false]{subfig}
% Improve table formatting. This defines three new commands \toprule,
% \midrule, and \bottomrule that should be used instead of \hline in
% tabular environments to get well formatted tables.
\usepackage{booktabs}
% Add support for drawing network packet diagrams. For documentation, see
% http://ctan.org/tex-archive/macros/latex/contrib/bytefield
\usepackage{bytefield}
% Add support for typesetting program source code. For documentation, see
% http://ctan.org/tex-archive/macros/latex/contrib/listings
\usepackage{listings}

% The hyperref package is problematic. Known issues include:
%  - Papers typeset without page numbers gives warnings of the form:
%      "pdfTeX warning (ext4): destination with the same identifier 
%      (name{page.}) has been already used, duplicate ignored".
%    since hyperref tries to refer to the page number.
%  - The algorithmic package uses the same line-numbering scheme for each
%    algorithm, and can cause duplicate identifier warnings if you have
%    several algorithms with line numbers (this may have been fixed with 
%    recent versions of algorithmic...).
%  - If using the algorithm package with hyperref, you need to load packages
%    in the following order (see README in hyperref documentation):
%      \usepackage{float}
%      \usepackage{hyperref}
%      \usepackage{algorithm}
% For these reasons, hyperref is best to avoid for most papers, however if
% needed, uncomment the following two lines:
%  \usepackage{float}
%  \usepackage{hyperref}

% The algorithm package defines the algorithm environment. This is used in
% the same way as the figure and table environments, to include algorithms
% in a paper. The algpseudocode package provides the ability to typeset the
% algorithms: http://ctan.org/tex-archive/macros/latex/contrib/algorithmicx
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{fancyvrb}
\usepackage{alltt}

\usepackage{color} % Add colour support:

% Define a simple \todo{...} macro:
\newcommand{\todo}[1]{\textbf{\textcolor{red}{To do: #1}}}

%==================================================================================================
\begin{document}
\title{Describing and Parsing QUIC Packets}

\author{Stephen McQuistin}
\affiliation{%
  \institution{University of Glasgow}
  \city{Glasgow, UK} 
}
\email{sm@smcquistin.uk}

\author{Colin Perkins}
\affiliation{%
  \institution{University of Glasgow}
  \city{Glasgow, UK} 
}
\email{csp@csperkins.org}

\date{\today}

%==================================================================================================
\begin{abstract}

% Four sentences:
%  - State the problem
%  - Say why it's an interesting problem
%  - Say what your solution achieves
%  - Say what follows from your solution

Standards documents have been slow to adopt formalisms that go beyond the limited syntax
that can be captured by ASCII packet diagrams. As increasingly complex protocols,
including QUIC, are standardised, this situation is likely to result in buggy,
non-conformant implementations. In this paper, we develop the Glasgow Packet
Representation, an abstract, intermediate representation that fully captures the syntax of
packet formats. By specifying an intermediate representation that can be generated from
existing formalisms, we hope to increase adoption, and incentivise the use of more
expressive formalisms. Formally specifying protocols reduces human error in the implementation
of parsers, and
increases the utility of standards documents.

\end{abstract}

\maketitle

%==================================================================================================
\section{Introduction}

% A good paper introduction is fairly formulaic. If you follow a simple set
% of rules, you can write a very good introduction. The following outline can
% be varied. For example, you can use two paragraphs instead of one, or you
% can place more emphasis on one aspect of the intro than another. But in all
% cases, all of the points below need to be covered in an introduction, and
% in most papers, you don't need to cover anything more in an introduction.
%
% Paragraph 1: Motivation. At a high level, what is the problem area you
% are working in and why is it important? It is important to set the larger
% context here. Why is the problem of interest and importance to the larger
% community?

ASCII packet header diagrams are the most common formalism found in IETF standards
documents. These diagrams allow for the visualisation packet formats, reducing human error
by aiding in the implementation of protocol parsers. However, while ASCII diagrams can
capture much of the syntax of existing protocols, like TCP and UDP, the complexity
introduced by newer protocols, such as QUIC \cite{draft-ietf-quic-transport-latest},
diminishes their utility. As a result, correct parser implementations are much more
reliant upon the careful interpretation of prose descriptions of the protocol's syntax.
This is a situation that is likely to result in buggy and non-conformant parser implementations.

% Paragraph 2: What is the specific problem considered in this paper? This
% paragraph narrows down the topic area of the paper. In the first
% paragraph you have established general context and importance. Here you
% establish specific context and background.

There are two broad issues with previous efforts to develop formalisms that better capture
the syntax of protocols. Firstly, most are largely unsuitable for protocols like QUIC.
QUIC uses encryption primitives throughout, including protected payloads. This means that
decryption must be modelled. Prior work, which has largely focussed on the parsing of
individual unencrypted packets, is unable to model this. As a result, QUIC, and the broader
shift towards pervasive encryption \cite{Rfc7258}, require a new formalism.

The second issue with existing approaches is that they generally define a new language
that standards authors should specify their protocols in. Their lack of widespread
adoption indicates that this approach is limited: standards documents require different
formalisms depending on the area. As a result, any approach that is likely to be adopted
must be flexible in the input formats that can be used.

% Paragraph 3: "In this paper, we show that...". This is the key paragraph
% in the introduction - you summarize, in one paragraph, what are the main
% contributions of your paper, given the context established in paragraphs 
% 1 and 2. What's the general approach taken? Why are the specific results
% significant? The story is not what you did, but rather:
%  - what you show, new ideas, new insights
%  - why interesting, important?
% State your contributions: these drive the entire paper.  Contributions
% should be refutable claims, not vague generic statements.

In this paper, we describe a framework for formalising the description of packet formats.
Our framework is comprised of three components: an input parser, an intermediary
representation (the Glasgow Packet Language), and an output formatter. This
architecture allows packets to be described using a number of different languages, and for
such descriptions to be parsed into a common intermediate form. Output formatters can then
use this intermediate representation to generate various artefacts, including parser code.
We provide an example of how this framework can be used to capture the complexity of QUIC.

% Paragraph 4: What are the differences between your work, and what others
% have done? Keep this at a high level, as you can refer to future sections
% where specific details and differences will be given, but it is important
% for the reader to know what is new about this work compared to other work
% in the area.

There have been many previous attempts at defining a packet format definition language,
including PacketTypes \cite{mccann2000packet}, Melange \cite{madhavapeddy2007melange},
PADS \cite{fisher2005pads}, and DataScript \cite{back2002datascript}. These languages
typically focus on the parsing of individual, unencrypted packets. Ad-hoc languages, such
as the presentation language used in the TLS 1.3 specification
\cite{draft-ietf-tls-tls13-28}, also see limited adoption. In contrast to these language
definitions, in this paper we develop an abstract protocol representation that, with
\emph{contexts} and \emph{functions} can describe the parsing of any protocol. We develop
a language that generates this intermediate representation, and give examples using QUIC.

% Paragraph 5: "We structure the remainder of this paper as follows." Give
% the reader a road-map for the rest of the paper. Try to avoid redundant
% phrasing, "In Section 2, In section 3, ..., In Section 4, ... ", etc.

We structure the remainder of this paper as follows. Section \ref{sec:motivation} expands
on our motivation, by assessing the utility provided by an ASCII diagram from the QUIC
standards documents, and outlining the requirements of our formalism. Section
\ref{sec:gpl} describes our proposed framework for describing packet formats,
including our intermediary representation, the Glasgow Packet Language. Section
\ref{sec:casestudy} provides an example of how our framework can be used to capture
the parsing of QUIC's PDUs. Finally, Section \ref{sec:related} discusses
related work, and Section \ref{sec:conclusion} concludes.

%==================================================================================================
% Concentrate single-mindedly on a narrative that:
%  - Describes the problem, and why it's interesting
%  - Describes your idea
%  - Defends your idea, showing how it solves the problem, and filling out
%    the details
% On the way, cite relevant work in passing, but defer discussion to the
% end.
%
% Introduce the problem, and your idea, using examples, and only then
% present the general case. Explain the idea as if your were speaking to
% someone using a whiteboard. Conveying the intuition is primary; details
% follow. Write in a top down manner: state broad themes and ideas first,
% then go into details.
%
% The introduction makes claims. The body of the paper provides evidence
% to support each claim. Check each claim in the introduction, identify
% the evidence, and forward-reference it from the claim. 
%==================================================================================================

\section{Motivation \& Requirements}
\label{sec:motivation}

\begin{figure}
	\centering
	\vspace{3mm}
    \begin{BVerbatim}[fontsize=\scriptsize]
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|0|K|1|1|0|R R R|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Destination Connection ID (0..144)           ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Packet Number (8/16/32)                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Protected Payload (*)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \end{BVerbatim}
    \caption{QUIC short header format (from \cite{draft-ietf-quic-transport-latest})}
    \label{fig:quic-short-hdr}
\end{figure}

Broadly, the requirements for our formalism are that it should:
\begin{itemize}
	\item be able to fully capture the information required for \emph{parsing} protocol
		  data units (PDUs);
	\item accommodate various PDU specification languages, including ASCII
		  packet header diagrams, ad-hoc languages
		  such as the TLS 1.3 presentation formation, and more generic packet description
		  languages;
	\item produce output in a number of formats, including ASCII diagrams, and parser
		  code.
\end{itemize}

To demonstrate the limitations of ASCII packet header diagrams in capturing all of the
information required to fully parse PDUs, we consider the diagram for QUIC's short header
PDU, as shown in Figure \ref{fig:quic-short-hdr}. From this diagram, it is clear how the
first octet should be parsed: the widths of each field are known, and, for some, the
values specified. However, it is not clear from the diagram how the Destination Connection
ID, Packet Number, and Protected Payload fields should be parsed. Determining the syntax
of these fields requires the prose descriptions that accompany the diagram; already, it is
clear that ASCII packet header diagrams are not sufficient.

Some of the limitations of ASCII diagrams can be avoided by using an existing packet
description language. Such languages typically allow for intricate field encodings to be
specified. For example, packet numbers use a variable-length integer encoding format,
where the most significant bits of the first octet determine the length of the field.
While it is impractical to represent this behaviour in an ASCII diagram, most packet
description languages enable this format to be captured.

However, we have identified two broad features that are missing from existing packet
description languages that mean that they cannot fully capture the behaviour of QUIC, or
other protocols with encrypted PDUs.

Firstly, existing languages typically enable per-packet modelling, but decryption in QUIC
requires information from packets earlier in the flow. We require flow-level
\emph{context}: essentially a key-value store that can be added to as parsing progresses,
and modelled as part of the protocol specification. For example, the nonce for decrypting
the protected payload field is derived from the packet number. However, the packet only
contains the least significant bits of this number. Contextual information from other
packets in the flow is required to generate the nonce.

Secondly, \emph{how} encrypted fields are parsed must be captured. Existing description
languages have been able to treat encrypted fields as unparsable blobs, enabled by the
separation between protocols. For example, where TCP is used to carry an encrypted
payload, the format of the payload is not specified as part of TCP: the parsing of TCP can
end with the payload as an encrypted blob. However, in QUIC, parsing a short header packet
requires that the protected payload by decrypted, and further parsed into frames. As a
result, we must model \emph{helper functions}, providing the prototype for functions
required in the parsing of the protocol.

To fulfil our second two requirements -- flexibility in both input and output formats --
our formalism must be an abstract, intermediary representation language. Such a
representation can be generated from an arbitrary set of input formats, and can itself be
used to produce various outputs. Abstracting and decoupling the input and output formats
in this way reduces complexity.

%==================================================================================================
\section{The Glasgow Packet Language}
\label{sec:gpl}

In this section, we describe the Glasgow Packet Language (GPL), an abstract protocol
representation language. The GPL is a strongly typed object-oriented language, that allows
for the format of protocol data units to be specified, alongside information on how these
PDUs should be parsed. The Glasgow Packet Language is comprised of both a runtime -- a set
of primitive types and traits -- and an \emph{intermediate representation} -- a set of
constructors that create or instantiate new types from the runtime's built-ins. We
describe each of these components in turn in Sections \ref{sec:gpl-runtime} and
\ref{sec:gpl-ir}.

That the GPL defines an intermediate representation is an important distinction from
existing approaches. We are not defining a language that those specifying protocols will
use, but rather a common format that any arbitrary format can be converted from and to.
For example, the GPL's intermediate representation might be generated by parsing the ASCII
diagrams in existing documents, and then used to generate a parser in C. We further
describe how the GPL fits into the standards process in Section \ref{sec:gpl-formats}.

%--------------------------------------------------------------------------------------------------
\subsection{Runtime}
\label{sec:gpl-runtime}

The intermediate representation -- described in Section \ref{sec:gpl-ir} -- is a set of
serialised JSON objects that describe the format of protocol data units, and how they
should be parsed. The objects that comprise the intermediate representation are
\emph{constructors}, that create new, protocol-specific types, that are derived from, or
instantiate, a set of built-in types. In this section, we describe the type system
provided by \emph{runtime} of the Glasgow Packet Language: that is, the interpreter for
the intermediate representation.

The runtime defines a set of primitive types that can be parsed or serialised (that is,
they are \emph{representable}):
\begin{itemize}
	\item Bit string
	\item Array
	\item Structure 
	\item Variant
	\item Function
	\item Protocol
	\item Context
\end{itemize}

Types are formed both by the types of value they can hold, and the \emph{traits} that they
implement. Traits define the methods that can be used on the types. The protocol type is
the top-level type of the intermediate representation; it contains the constructors for
the protocol-specific types, and lists the PDUs that comprise the protocol. We omit
discussion of the bit string, array, and variant types: these are intuitive, and broadly
match with traditional definitions.

The structure type also largely matches its widely used definition. However, the GPL
augments the typical C-style composite type in two important ways. Firstly, each field of
the structure can be associated with a \emph{transformation}: this captures if, and how,
the field changes after it has been parsed. For example, in QUIC, payloads are protected:
the payload field begins with an encrypted bit string type, and after parsing, is
transformed into a field with that is an array of frames. Importantly, these
transformations are needed in the parsing process: parsing of a PDU would not be complete
without decrypting the protected payload. Secondly, structures have a set of constraints:
expressions that define structures by limiting the values that their fields can hold. For
example, a structure might have the same layout as another, but differ on the value of a
particular field.

The function type holds the signature of external helper functions, and consists of the
function's name, parameters (their name and type), and return type. The body of the
function is \emph{not} captured. As described above, functions are necessary when
modelling the parsing process.

The context type defines the variables (their name and type) that can be accessed in the
parsing of PDUs, by helper functions, or out-of-band (e.g., in code that handles PDU
serialisation). The context holds the internal state for the parser: it is used to store
data that is necessary for parsing to progress.

In addition to these representable types, the runtime also has a number of \emph{internal}
types: these are types that are used within the runtime, but that cannot be parsed or
serialised. These are intuitive, and include booleans and integers.

%--------------------------------------------------------------------------------------------------
\subsection{Intermediate representation}
\label{sec:gpl-ir}

The runtime defines a constructor for each of the representable types described in the
previous section. These constructors instantiate new types derived from the parameterised
base type. For example, a constructor might be used to construct a 16-bit bit string, with
the name \emph{Int16}. \emph{Int16} then becomes a type that can be used throughout the
intermediate representation. Derived types can also be further defined by implementing
additional traits. For example, \emph{Int16} could implement ordinal and boolean traits to
make it an integer type.

The high-level object of the intermediary representation is a protocol object; exactly
one protocol type must be constructed. The protocol object then contains a list of
constructors for the other types instantiated. With the exception of the context type,
any number of constructors may be defined; at most one context can be constructed, given
its nature. Finally, the protocol type includes a list of the PDUs that comprise the
protocol, based on the constructed types.

%--------------------------------------------------------------------------------------------------
\subsection{Input parsers \& output formatters}
\label{sec:gpl-formats}

The intermediate representation is serialised using JSON. By using a widely adopted
notation, the code used to both generate the representation, and use it, is not tied to a
particular programming language. The role of the intermediate representation is to join
together two arbitrary programs: one that generates it, and another that uses it to
produce output, such as a parser.

This means that the Glasgow Packet Language differs from previous work in this area:
protocol designers do not formalise their specifications using the language itself, but
rather, they use whichever formalism is appropriate, and develop tooling around that. For
example, the QUIC protocol documents make use of ASCII packet diagrams and the TLS 1.3
presentation language. Tooling can be developed to parse these existing formalisms from
the documents, and to generate the intermediate representation. This approach fits better
with the standardisation process used in bodies like the IETF: prior efforts to introduce
formalisms have largely failed because of their expectation that protocol authors must
change how they write specifications. The Glasgow Packet Language's intermediate
representation can be generated from any formalism, but the level of detail captured
varies with the expressiveness of that formalism.

The same flexibility in how the intermediate representation is generated also applies to
how it can be used to derive output formats: any program that can interpret the JSON
format can read the intermediate representation can generate output from it. There are
obvious use cases, such as generating ASCII packet diagrams or stubbing out parsers in C.
But ultimately, the benefit of the approach here is that the output is not coupled to the
input format: code that takes the intermediate representation and generates a C parser can
be written once, and reused regardless of how the intermediate representation was
generated.

An additional benefit to having a common intermediate representation is that tooling can
be developed around it, without duplicated effort. Such tooling could type check the
intermediate representation, to ensure that it had been generated correctly.

%==================================================================================================
\section{Example: Parsing QUIC}
\label{sec:casestudy}

\begin{figure}
	\vspace{3mm}
    \begin{BVerbatim}[fontsize=\scriptsize]
VarInt := {
	two_bit       : Bit2;
	value         : Bits;
} where {
	value.length == (8*(2^two_bit))-2;
};

lh_packetnum_decrypt :: (ppacket_num : PPacketNum, 
                         context : Context) 
                     -> PacketNum;
                     
Context := {
	highest_packet_num  : PacketNum;
	last_scid           : ConnectionID;
};

LongHeader := {
	header_form   : Bit;
	packet_type   : LongHeaderType;
	version       : Version;
	dcil          : Bit4;
	scil          : Bit4;
	dcid          : ConnectionID;
	scid          : ConnectionID;
	length        : VarInt;
	ppacket_num   : PPacketNum -> packet_num : PacketNum;
	payload       : Frame[];
} where {
	header_form == 1;
	dcid.size == ((dcil == 0) ? 0 : dcil+3);
	scid.size == ((scil == 0) ? 0 : scil+3);
} onparse {
	packet_num = lh_packetnum_decrypt(ppacket_num, Context);
};
    \end{BVerbatim}
    \caption{QUIC long header (from \cite{draft-ietf-quic-transport-latest})}
    \label{fig:quic-long-hdr-desc}
\end{figure}

In this section, we will demonstrate that the novel features of the Glasgow Packet
Language -- functions and context -- are necessary in describing QUIC. We illustrate this
using an example that formalises some of QUIC's PDUs using a protocol description
language. As discussed in the previous section, this language is unimportant: the
intermediate representation that the Glasgow Packet Language produces is agnostic to
input and output formats. Additionally, the examples used in this section are not
exhaustive: our goal is to demonstrate that the features of the GPL are necessary to
fully model the parsing of QUIC.

We begin, in Figure~\ref{fig:quic-long-hdr-desc}, by describing QUIC's long header
format. This code generates a structure named \texttt{LongHeader}, with the fields
(written as \texttt{name : type}) specified in the first block. The \texttt{Bit} and 
\texttt{Bit4} types are intuitive, specifying bit strings of length 1 and 4 respectively.
The \texttt{VarInt} type is also specified; this encodes QUIC's variable-length integer
encoding format. We omit descriptions of the other complex data types used in the
long header format.

The \texttt{where} block contains expressions that form the structure's constraints. A PDU
can only be parsed if \emph{all} of the constraints are true. Already, we can see an
advantage of this simple programmatic description of the long header: the relationship
between the \texttt{dcil}/\texttt{scil} and \texttt{dcid}/\texttt{scid} fields is made
explicit. In the standards documents, where ASCII packet diagrams are used, the
\texttt{dcid}/\texttt{scid} fields are shown as having variable lengths; the prose
description accompanying the diagram is needed to fully describe the packet format.

The \texttt{onparse} block contains actions that are to be performed once the PDU has been
successfully parsed as a \texttt{LongHeader} structure (i.e., its layout matches that of
the structure, and all of the constraints in the \texttt{where} block are true). The
single expression in this section is matched with the following field of the structure:
\footnotesize
\begin{alltt}
    ppacket_num : PPacketNum -> packet_num : PacketNum
\end{alltt}
\normalsize
This is a field transformation: together, these lines indicate that the parsed block
contains a protected packet number field (with type \texttt{PPacketNum}), which, to allow
for further parsing, is then transformed (using the \texttt{lh\_packetnum\_decrypt} function)
into a packet number field (with type \texttt{PacketNum}). The goal of the intermediate
representation is to capture the signature of the functions required in the parsing of the
protocol. At present, much of this behaviour is captured in prose descriptions of the
protocol, limiting the usefulness of the ASCII packet diagrams the documents provide.
This issue is exacerbated by the TLS-related functionality being described in a separate
document (in this case, packet number protection is described in Section 5.3 of the
QUIC-TLS draft \cite{draft-ietf-quic-tls-14}). Using explicit function names would provide
a concrete way of linking these non-trivial components together. 

Finally, Figure~\ref{fig:quic-long-hdr-desc} includes a definition of the context. As
described in the previous section, the context is a key-value store that spans the duration
of the parsing process. As PDUs are parsed, they can access the context. In addition,
functions that are called can take the context as a parameter, and the context can be
modified out-of-band. Here, we define the context to include a \texttt{highest\_packet\_num}
field. As part of \texttt{lh\_packetnum\_decrypt}'s removal of packet number protection,
the packet number is decoded. This requires the highest received packet number to be
stored; the context is necessary for this.

\begin{figure}
	\vspace{3mm}
    \begin{BVerbatim}[fontsize=\scriptsize]
decrypt :: (ppayload : Bits, 
            context : Context) 
        -> Frame[];
                     
ShortHeader := {
	header_form   : Bit;
	key_phase     : Bit;
	third_bit     : Bit;
	forth_bit     : Bit;
	demux_bit     : Bit;
	reserved      : Bit[3];
	dcid          : ConnectionID;
	ppacket_num   : PPacketNum -> packet_num : PacketNum;
	ppayload      : Bits -> payload : Frame[];
} where {
	header_form == 0;
	third_bit == 1;
	forth_bit == 1;
	demux_bit == 0;
	dcid == Context.scid;
} onparse {
	packet_num = sh_packetnum_decrypt(ppacket_num);
	payload = decrypt(ppayload);
};
    \end{BVerbatim}
    \caption{QUIC short header (from \cite{draft-ietf-quic-transport-latest})}
    \label{fig:quic-short-hdr-desc}
\end{figure}

Next, we consider the short header, as shown in Figure~\ref{fig:quic-short-hdr-desc}.
Beyond the features already discussed as part of the long header example, the short header
also includes a reference to the context. The short header's \texttt{dcid} field must
match the most recent source connection ID that has been sent. This demonstrates another
way in which the context can be accessed: the sending process is essentially out-of-band,
but information must be shared with the parsing process to allow it to progress.

\begin{figure}
	\vspace{3mm}
    \begin{BVerbatim}[fontsize=\scriptsize]
PaddingFrame := {
	frame_type   : VarInt;
} where {
	frame_type == 0;
};

Frame := { PaddingFrame | RSTStreamFrame | ConnectionCloseFrame | .. };
    \end{BVerbatim}
    \caption{QUIC frames (from \cite{draft-ietf-quic-transport-latest})}
    \label{fig:quic-frame-desc}
\end{figure}

This is the central argument for requiring helper functions and context: decryption (in
the form of packet and payload protection, for example) are primitives of the QUIC
protocol. If we are to design an intermediate language that can model the parsing of QUIC
PDUs, it \emph{must} allow for the modelling of decryption. This is further illustrated
by the link between the short header format's protected payload, and the QUIC frames (as
shown in Figure~\ref{fig:quic-frame-desc}) that it ultimately contains. It is not sufficient
to treat the protected payload as an encrypted blob: this does not fully model the parsing
process. As shown, a short header PDU is parsed, and the payload is decrypted using the
\texttt{decrypt} function, which takes both the protected payload and the context (for any
information needed to decrypt the payload), and returns an array of frames. The frames are
then parsed as the \texttt{Frame} type defined in Figure~\ref{fig:quic-frame-desc}.

%==================================================================================================
\section{Related Work}
\label{sec:related}

% This should come near the end, and focussing on discussing how your work
% relates to that of others. Any relevant related work should have been
% cited already, so this is not a list of related work, it's a discussion
% of how that work relates.
%
% Why not put related work after the introduction? 1) because describing
% alternative approaches gets between the reader and your idea; and 2)
% because the reader knows nothing about the problem yet, so your
% (carefully trimmed) description of various technical trade-offs is
% absolutely incomprehensible.
% 
% When writing the related work:
%  - Give credit to others where it's due; this doesn't diminish the
%    credit you get from your paper. 
%  - Acknowledge weaknesses in your approach.
%  - Ensure related work is accurate and up-to-date

There have been many previous efforts to develop a description language for protocol
parsing. Many approaches, such as PADS (Processing Ad Hoc Data Sources)
\cite{fisher2005pads} and DataScript \cite{back2002datascript}, are C-like in their
syntax and type systems. Others, like PacketTypes \cite{mccann2000packet} and the Meta
Packet Language (MPL) \cite{madhavapeddy2007melange}, are declarative, with more expressive
type systems. None of these approaches include support for contexts or helper functions:
there is no way to model the decryption primitives that are essential to the parsing of
QUIC. Ultimately, while these languages are well-motivated (i.e., parser quality would
be improved by formal specifications in standards documents), they misunderstand the
approach the needs of standards authors. 

In terms of adoption, it is interesting to consider the approaches that see use in IETF
documents. The most widespread formalism is the ASCII packet diagram. While this is
limited in its expressiveness, its value in showing the layout of protocol PDUs should not
be ignored. Other formalisms, such as ASN.1 \cite{x680} and the TLS 1.3 presentation
format \cite{draft-ietf-tls-tls13-28}, see widespread adoption within certain IETF
working groups, but almost no adoption in most. This points to the problem noted above: a
single input language is not suitable in all cases. The flexibility of our approach --
defining an intermediate representation, rather than a language that authors write -- means
that existing formalisms, including ASCII diagrams and the TLS 1.3 presentation language,
can be used as input formats. 

The flexibility is also beneficial in terms of the output formats that can be derived from
the intermediate representation.
P4 \cite{bosshart:2014:p4,p4consortium:2018:v16spec-20180531} is a language
for programming the data plane of network devices. It is widely used in
software defined networking applications.
P4 describes how packets are parsed and serialised and what state tables
exist in a network devices, and specifies a series of match-action rules
that describe the packet processing and forwarding behaviour of the device.
Parsers in P4 are implemented imperatively, and are built-up from a series
of state machines.
In terms of expressive power, parsers in P4 are comparable to the parsers
we describe and can parse the same formats.
Our approach differs from P4 in that we declaratively define the packet
format, and derive the parser implementation from that declaration. P4,
on the other hand, simply specifies the parser implementation. As such,
P4 could be an appropriate output language for our system.

%==================================================================================================
\section{Conclusions}
\label{sec:conclusion}

In this paper, we have described the Glasgow Packet Language (GPL), a runtime and
intermediate representation that can be used to model the parsing of protocol PDUs. GPL
builds on existing approaches in three important ways. First, in recognising that
encryption primitives are a fundamental component of new protocols, we allow for
out-of-band helper functions to be modelled. A related addition is the inclusion of a
persistent (across the parsing process) context, to allow for data to be exchanged between
the parsing of different PDUs, or out-of-band logic. Finally, the GPL defines an
intermediate language that can be generated from any input format, and can be similarly
used to generate output in any format.

Future work begins with formally specifying the Glasgow Packet Language, and providing
example input and output formatters. In addition, tooling will be developed that allows
for the intermediate representation to be type checked. In providing these examples, and
developing this tooling, we will illustrate the benefit of a common intermediate
representation: the effort required to support a new input or output format is not
duplicated.

Ultimately, a common representation enables the use of formal specifications without rapid
change in the way that protocols are specified. The intermediate representation can be
generated by parsing ASCII diagrams as they are written today. While this would lack the
expressiveness of more formal description (such as the examples in Section
\ref{sec:casestudy}), it would expose the benefits of the general approach, and
incentivise authors to move beyond ASCII diagrams. We believe that this piecemeal approach
fits better with the standardisation process: no single input format or output language is
desirable.

%==================================================================================================
\section{Acknowledgements}

This work is funded by the UK Engineering and Physical Sciences Research Council, under
grant EP/R04144X/1.

%==================================================================================================
% Set the bibliography style. 
\bibliographystyle{abbrvurl}
% The abbrvurl style comes from https://www.ctan.org/pkg/urlbst, and is
% included in most standard TeX distributions. It adds support for DOIs
% to the standard abbrv style.
%
% When using the IEEE style, replace the above line with:
%   \bibliographystyle{IEEEtran} 
% The IEEEtran.bst file included here has been modified to support DOIs.

% Load the bibliography file for this paper:
\bibliography{improving-quic-docs}

%==================================================================================================
% The following information gets written into the PDF file information:
\ifpdf
  \pdfinfo{
    /Title        (...)
    /Author       (...)
    /Subject      (...)
    /Keywords     (..., ..., ...)
    /CreationDate (D:20150827110616Z)
    /ModDate      (D:20150827110616Z)
    /Creator      (LaTeX)
    /Producer     (pdfTeX)
  }
  % Suppress unnecessary metadata, to ensure the PDF generated by pdflatex is
  % identical each time it is built:
  \ifdefined\pdftrailerid
    % The \pdftrailerid and \pdfsuppressptexinfo macros were both introduced 
    % in pdfTeX 3.14159265-2.6-1.40.17. If one is present, the other will be.
    \pdftrailerid{}
    \pdfsuppressptexinfo=15
  \fi
\fi
%==================================================================================================
\end{document}
% vim: set ts=2 sw=2 tw=75 et ai:
